#lang racket
(provide
  (all-from-out "common.rkt")
  (struct-out true)
  (struct-out false)
  (struct-out disj)
  (struct-out conj)
  (struct-out relate)
  (struct-out ==)
  (struct-out =/=)
  (struct-out symbolo)
  (struct-out stringo)
  (struct-out numbero)
  (struct-out pairo)
  (struct-out listo)
  (struct-out not-symbolo)
  (struct-out not-stringo)
  (struct-out not-numbero)
  (struct-out not-pairo)
  (struct-out not-listo)
  (struct-out imply)
  (struct-out existential)
  (struct-out universal)
  (struct-out mplus)
  (struct-out bind)
  (struct-out pause)
  step
  mature
  mature?
  normalize-goal)

(require "common.rkt")

;; first-order microKanren
(struct true        ()                       #:prefab)
(struct false       ()                       #:prefab)
(struct disj        (g1 g2)                  #:prefab)
(struct conj        (g1 g2)                  #:prefab)
(struct relate      (thunk description)      #:prefab)
(struct not-relate  (thunk description)      #:prefab)
(struct ==          (t1 t2)                  #:prefab)
(struct =/=         (t1 t2)                  #:prefab)
(struct symbolo     (t)                      #:prefab)
(struct stringo     (t)                      #:prefab)
(struct numbero     (t)                      #:prefab)
(struct pairo       (t)                      #:prefab)
(struct listo       (t)                      #:prefab)
(struct not-symbolo (t)                      #:prefab)
(struct not-stringo (t)                      #:prefab)
(struct not-numbero (t)                      #:prefab)
(struct not-pairo   (t)                      #:prefab)
(struct not-listo   (t)                      #:prefab)
(struct imply       (g1 g2)                  #:prefab)
(struct existential (v g)                    #:prefab)
(struct universal   (v g)                    #:prefab)
(struct bind        (bind-s bind-g)          #:prefab)
(struct mplus       (mplus-s1 mplus-s2)      #:prefab)
(struct pause       (pause-state pause-goal) #:prefab)

(define (negate-goal g)
  (cond
    ((true? g)        (false))
    ((false? g)       (true))
    ((disj? g)        (conj (negate-goal (disj-g1 g)) (negate-goal (disj-g2 g))))
    ((conj? g)        (disj (negate-goal (conj-g1 g)) (negate-goal (conj-g2 g))))
    ((==? g)          (=/= (==-t1 g) (==-t2 g)))
    ((=/=? g)         (== (=/=-t1 g) (=/=-t2 g)))
    ((typeo? g)       (type->goal (typeo-t g) (typeo->type? g) #t))
    ((not-typeo? g)   (type->goal (typeo-t g) (typeo->type? g)))
    ((imply? g)       (conj (imply-g1 g) (negate-goal (imply-g2 g))))
    ((existential? g) (universal (existential-v g) (negate-goal (existential-g g))))
    ((universal? g)   (existential (universal-v g) (negate-goal (universal-g g))))
    ((relate? g)      (not-relate (relate-thunk g) (relate-description g)))
    ((not-relate? g)  (relate (not-relate-thunk g) (not-relate-description g)))
    (else             (error "Unnegateable goal" g))))

(define (mature? s) (or (not s) (pair? s)))
(define (mature s)
  (if (mature? s) s (mature (step s))))

(define (start st g)
  ;(match (combine-diseqs (normalize-decidable g))
  (match (combine-diseqs (simplify g))
    ((true) (state->stream st))
    ((false) (state->stream #f))
    ((disj g1 g2)
     (step (mplus (pause st g1)
                  (pause st g2))))
    ((conj g1 g2)
     (step (bind (pause st g1) g2)))
    ((relate thunk _)
     (pause st (thunk)))
    ((not-relate thunk _)
     (pause st (negate-goal (thunk))))
    ((== t1 t2) (state->stream (unify t1 t2 st)))
    ((=/= t1 t2) (state->stream (disunify t1 t2 st)))
    ((symbolo t) (state->stream (typify t symbol? st)))
    ((stringo t) (state->stream (typify t string? st)))
    ((numbero t) (state->stream (typify t number? st)))
    ((pairo t)   (state->stream (typify t pair? st)))
    ((listo t)   (state->stream (typify t list? st)))
    ((not-symbolo t) (state->stream (not-typify t symbol? st)))
    ((not-stringo t) (state->stream (not-typify t string? st)))
    ((not-numbero t) (state->stream (not-typify t number? st)))
    ((not-pairo t)   (state->stream (not-typify t pair? st)))
    ((not-listo t)   (state->stream (not-typify t list? st)))
    ((imply g1 g2)
     (step (mplus (pause st (negate-goal g1))   ;;? This will only work the the goal g1 is decidable, how will we solve non-decidable goals?
                  (pause st (conj g1 g2)))))
    ((existential v g) (step (pause (add-to-scope v 'e st) g)))
    ((universal v g) (error "not enough rules: forall"))
    ))

(define (step s)
  (match s
    ((mplus s1 s2)
     (let ((s1 (if (mature? s1) s1 (step s1))))
       (cond ((not s1) s2)
             ((pair? s1)
              (cons (car s1)
                    (mplus s2 (cdr s1))))
             (else (mplus s2 s1)))))
    ((bind s g)
     (let ((s (if (mature? s) s (step s))))
       (cond ((not s) #f)
             ((pair? s)
              (step (mplus (pause (car s) g)
                           (bind (cdr s) g))))
             (else (bind s g)))))
    ((pause st g) (start st g))
    (_            s)))

(define (decidable? g)
  (cond
    ((true? g)         #t)
    ((false? g)        #t)
    ((==? g)           #t)
    ((=/=? g)          #t)
    ((disj/conj? g)    (and (decidable? (disj/conj-g1 g)) (decidable? (disj/conj-g2 g))))
    ((typeo? g)        #t)
    ((not-typeo? g)    #t)
    ((imply? g)        (and (decidable? (imply-g1 g)) (decidable? (imply-g2 g))))
    ((existential? g)  (decidable? (existential-g g)))
    ((universal? g)    (decidable? (universal-g g)))
    ((relate? g)       #f)
    ((not-relate? g)   #f)
    (else              #f)))

(define (normalize-decidable g [DNF? #t])
  (cond
    ((decidable? g) (normalize-goal g DNF?))
    ((disj/conj? g) (let ((g1 (normalize-decidable (disj/conj-g1 g) DNF?)))
                      (match g1
                        ((true)   (if (disj? g) (true) (normalize-decidable (conj-g2 g) DNF?)))
                        ((false)  (if (disj? g) (normalize-decidable (disj-g2 g) DNF?) (false)))
                        (_        (let ((g2 (normalize-decidable (disj/conj-g2 g) DNF?)))
                                    (match g2
                                      ((true)   (if (disj? g) (true) g2))
                                      ((false)  (if (disj? g) g1 (false)))
                                      (_        (if (disj? g) (disj g1 g2) (conj g1 g2)))))))))
    ((imply? g)     (let ((g1 (normalize-decidable (imply-g1 g) DNF?)))
                      (cond 
                        ((true? g1)   (normalize-decidable (imply-g2 g) DNF?))
                        ((false? g1)  (true))
                        (else         (let ((g2 (normalize-decidable (imply-g2 g) DNF?)))
                                        (if (decidable? g1)
                                            (disj (normalize-goal (negate-goal g1) DNF?) g2)
                                            (imply g1 g2)))))))
    ((existential? g) (existential (existential-v g) (normalize-decidable (existential-g g) DNF?)))
    ((universal? g)   (universal (universal-v g) (normalize-decidable (universal-g g) DNF?)))
    (else             g)))

(define (unfold g)
  (match g
    ((disj g1 g2)         (disj (unfold g1) (unfold g2))) ;; overly eager? Unfold one side
    ((conj g1 g2)         (conj (unfold g1) (unfold g2)))
    ((imply g1 g2)        (imply (unfold g1) (unfold g2)))
    ((existential v h)    (existential v (unfold h)))
    ((universal v h)      (universal v (unfold h)))
    ((relate thunk _)     (thunk))
    ((not-relate thunk _) (negate-goal (thunk)))
    (_                    g)))

(define (simplify g) ;; Change this to do something different if after normalaization we get a disj that has at least one part deciable
  ; (displayln g)
  ; (newline)
  (let ((g (normalize-goal g)))
    (cond
      ((decidable? g) g)
      ((and (disj? g) (decidable? (disj-g1 g)))
        (disj (disj-g1 g) (disj-g2 g)))
      ((and (disj? g) (decidable? (disj-g2 g)))
        (disj (disj-g2 g) (disj-g1 g)))
      (else
        (simplify (unfold g))))))

(define (normalize-goal g [DNF? #t])
  (match g
    ;; Remove lists/pairs
    ((== (cons f1 r1) (cons f2 r2)) (normalize-goal (conj (== f1 f2) (== r1 r2))))
    ((== (cons f1 r1) t2) (if (var? t2) (== (cons f1 r1) t2) (false)))
    ((== t1 (cons f2 r2)) (if (var? t1) (== (cons f2 r2) t1) (false)))

    ((=/= (cons f1 r1) (cons f2 r2)) (normalize-goal (disj (=/= f1 f2) (=/= r1 r2))))
    ; ((=/= (cons f1 r1) t2) (if (var? t2) (=/= (cons f1 r1) t2) (false)))
    ; ((=/= t1 (cons f2 r2)) (if (var? t1) (=/= (cons f2 r2) t1) (false)))

    ((== t1 t2)             (cond
                              ((equal? t1 t2) (true))
                              ((and (var? t1) (term-use-var? t2 t1) (not (var? t2))) (false))
                              ((and (var? t2) (term-use-var? t1 t2) (not (var? t1))) (false))
                              ((and (or (contains-fresh? t1) (contains-fresh? t2)) (term<? t1 t2)) (== t1 t2))
                              ((or (contains-fresh? t1) (contains-fresh? t2)) (== t2 t1))
                              (else (false))))
    ((=/= t1 t2)            (cond
                              ((equal? t1 t2) (false))
                              ((and (var? t1) (term-use-var? t2 t1) (not (var? t2))) (true))
                              ((and (var? t2) (term-use-var? t1 t2) (not (var? t1))) (true))
                              ((and (or (contains-fresh? t1) (contains-fresh? t2)) (term<? t1 t2)) (=/= t1 t2))
                              ((or (contains-fresh? t1) (contains-fresh? t2)) (=/= t2 t1))
                              (else (true))))

    ;; Recursive normalization
    ((disj g1 g2)           (normalize-disj g1 g2 DNF?))
    ((conj g1 g2)           (normalize-conj g1 g2 DNF?))
    ((imply g1 g2)          (normalize-imply g1 g2 DNF?))
    ((existential v h)      (normalize-existential v h DNF?))
    ((universal v h)        (normalize-universal v h DNF?))

    (g                      (cond
                              ((typeo? g)     (let ((t (typeo-t g))) (if (var? t) g (if ((typeo->type? g) t) (true) (false))))) ;; Generalized type constraint
                              ((not-typeo? g) (let ((t (typeo-t g))) (if (var? t) g (if ((typeo->type? g) t) (false) (true))))) ;; Generalized not-type constraint
                              (else           g))))) ;; No simplification possible

(define (normalize-disj g1 g2 [DNF? #t])
  (let ((g1 (normalize-goal g1 DNF?)))
    (cond
      ((true? g1)  (true))                      ;; True or A = True
      ((false? g1) (normalize-goal g2 DNF?))    ;; False or A = A
      (else (let ((g2 (normalize-goal g2 DNF?)))
              (cond
                ((true? g2)   (true))           ;; A or True = True
                ((false? g2)  g1)               ;; A or False = A
                ; ((and (not DNF?) (conj? g1))  (normalize-goal (conj (disj (conj-g1 g1) g2) (disj (conj-g2 g1) g2)) DNF?));;(error "CNF not implemented"))
                ; ((and (not DNF?) (conj? g2))  (normalize-goal (conj (disj g1 (conj-g1 g2)) (disj g1 (conj-g2 g2))) DNF?));;(error "CNF not implemented"))
                ((disj? g1) (normalize-goal (disj (disj-g1 g1) (disj (disj-g2 g1) g2)) DNF?))
                ((and (disj? g2) (goal-diseq-first<? (disj-g1 g2) g1)) (normalize-goal (disj (disj-g1 g2) (disj g1 (disj-g2 g2))) DNF?))
                ((goal-diseq-first<? g2 g1) (normalize-goal (disj g2 g1) DNF?))
                ((or (=/=? g1) (typeo? g1) (not-typeo? g1))
                  (let ((g2 (if (=/=? g1)
                                (substitute-term g2 (=/=-t2 g1) (=/=-t1 g1) DNF?)
                                (apply-type g2 (typeo-t g1) (typeo->type? g1) DNF? (typeo? g1)))))
                    (match g2
                      ((true)   (true))
                      ((false)  g1)
                      (_        (disj g1 g2)))))
                ((and (disj? g2) (goal=? g1 (disj-g1 g2))) (disj g1 (disj-g2 g2))) ;; A or (A or B) = A or B
                ((goal=? g1 g2) g1)             ;; A or A = A
                ((negation? g1 g2) (true))      ;; A or ~A = True
                (else (disj g1 g2))))))))

(define (normalize-conj g1 g2 [DNF? #t])
  (let ((g1 (normalize-goal g1 DNF?)))
    (cond
      ((true? g1)   (normalize-goal g2 DNF?))   ;; True and A = A
      ((false? g1)  (false))                    ;; False and A = False
      (else (let ((g2 (normalize-goal g2 DNF?)))
              (cond
                ((true? g2)   g1)               ;; A and True = A
                ((false? g2)  (false))          ;; A and False = False
                ; ((and DNF? (disj? g1)) (normalize-goal (disj (conj (disj-g1 g1) g2) (conj (disj-g2 g1) g2)) DNF?))  ;; (A or B) and C = (A and C) or (B and C)
                ; ((and DNF? (disj? g2)) (normalize-goal (disj (conj g1 (disj-g1 g2)) (conj g1 (disj-g2 g2))) DNF?))  ;; A and (B or C) = (A and B) or (A and C)
                ((conj? g1) (normalize-goal (conj (conj-g1 g1) (conj (conj-g2 g1) g2)) DNF?))            ;; (A and B) and C = A and (B and C)
                ((and (conj? g2) (goal<? (conj-g1 g2) g1)) (normalize-goal (conj (conj-g1 g2) (conj g1 (conj-g2 g2))) DNF?))
                ((goal<? g2 g1) (normalize-goal (conj g2 g1) DNF?))
                ((or (==? g1) (typeo? g1) (not-typeo? g1))
                  (let ((g2 (if (==? g1)
                                (substitute-term g2 (==-t2 g1) (==-t1 g1) DNF?)
                                (apply-type g2 (typeo-t g1) (typeo->type? g1) DNF? (not-typeo? g1)))))
                    (match g2
                      ((true)   g1)
                      ((false)  (false))
                      (_        (conj g1 g2)))))
                ((and (conj? g2) (goal=? g1 (conj-g1 g2))) (conj g1 (conj-g2 g2))) ;; A and (A and B) = A and B
                ((goal=? g1 g2) g1)             ;; A and A = A
                ((negation? g1 g2) (false))     ;; A and ~A = False
                (else (conj g1 g2))))))))

(define (replace-implication ant con)
  (if (conj? ant)
      (replace-implication (conj-g2 ant) (replace-assumption-with-true (conj-g1 ant) con))
      (replace-assumption-with-true ant con)))

(define (normalize-imply g1 g2 [DNF? #t])
  (let ((g1 (normalize-goal g1 DNF?)))
    (match g1
      ((true) (normalize-goal g2 DNF?))     ;; True -> A  = A
      ((false) (true))                      ;; False -> A = True
      (_       (let* ((g2 (normalize-goal g2 DNF?))
                      (g2 (normalize-goal (replace-implication g1 g2) DNF?)))
                  (cond
                    ((true? g2) (true))
                    ((universal? g1) (normalize-goal (existential (universal-v g1) (imply (universal-g g1) g2)) DNF?)) ;; (forall v A) -> B = exists v (A -> B)
                    ((existential? g1) (normalize-goal (universal (existential-v g1) (imply (existential-g g1) g2)) DNF?)) ;; (forall v A) -> B = exists v (A -> B)
                    (else (let ((g1 (normalize-goal (negate-goal g1) DNF?)))
                      (normalize-goal (disj g1 g2) DNF?)))))))))  ;; A -> B = ~A or B

(define (normalize-existential v g [DNF? #t])
  (let ((g (normalize-goal g DNF?)))
    (cond
      ((true? g)  (true))
      ((false? g) (false))
      ((==? g)    (let ((t1 (==-t1 g)) (t2 (==-t2 g)))
                    (cond
                      ((or (equal? t1 v) (equal? t2 v)) (true))
                      ((or (term-use-var? t1 v) (term-use-var? t2 v)) (existential v g))
                      (else g))))
      ((=/=? g)   (if (or (term-use-var? (=/=-t1 g) v) (term-use-var? (=/=-t2 g) v)) (true) g))
      ((or (typeo? g) (not-typeo? g)) (if (term-use-var? (typeo-t g) v) (true) g))
      ((imply? g)   (if (or (goal-use-var? (imply-g1 g) v) (goal-use-var? (imply-g2 g) v))
                        (existential v g)
                        g))
      ((existential? g)  (if (goal-use-var? (existential-g g) v) (existential v g) g))
      ((universal? g) (if (goal-use-var? (universal-g g) v)
                        (existential v g)
                        (normalize-goal (negate-goal (normalize-goal (negate-goal g) DNF?)) DNF?))) ;;! Infinite recursion?
      ((disj? g)    (let* ((g1 (disj-g1 g)) 
                           (g2 (disj-g2 g))
                           (no-v-in-g1? (not (goal-use-var? g1 v)))
                           (no-v-in-g2? (not (goal-use-var? g2 v))))
                      (cond
                        ((and no-v-in-g1? no-v-in-g2?) g)
                        (no-v-in-g1? (normalize-goal (disj g1 (existential v g2)) DNF?))
                        (no-v-in-g2? (normalize-goal (disj g2 (existential v g1)) DNF?))
                        (else (normalize-goal (disj (existential v g1) (existential v g2)) DNF?)))))
      ((conj? g)    (let* ((g1 (conj-g1 g))
                           (g2 (conj-g2 g))
                           (no-v-in-g1? (not (goal-use-var? g1 v)))
                           (no-v-in-g2? (not (goal-use-var? g2 v))))
                      (cond
                        ((and no-v-in-g1? no-v-in-g2?) g)
                        (no-v-in-g1? (normalize-goal (conj g1 (existential v g2)) DNF?))
                        (no-v-in-g2? (normalize-goal (conj g2 (existential v g1)) DNF?))
                        ; ((and (=/=? g1) (=/=? g2)) (true))
                        ; ((and (=/=? g1) (conj? g2) (=/=? (conj-g1 g2))) (true))
                        ; ((and (not-typeo? g1) (not-typeo? g2) (equal? (typeo-t g1) (typeo-t g2))) (true))
                        ; ((and (not-typeo? g1) (conj? g2) (not-typeo? (conj-g1 g2)) (equal? (typeo-t g1) (typeo-t (conj-g1 g2))) (true)))
                        ((and DNF? (==? (conj-g1 g)) (disj? (conj-g2 g))) (normalize-goal (disj (existential v (conj (conj-g1 g) (disj-g1 (conj-g2 g)))) (existential v (conj (conj-g1 g) (disj-g2 (conj-g2 g))))) DNF?))
                        (else (existential v g)))))
      (else         (existential v g)))))

(define (normalize-universal v g [DNF? #t] [induction? #t])
  (cond
    ((and induction? (imply? g)) ;; List induction rewrite rules
      (let* ((g1 (normalize-goal (imply-g1 g) DNF?))
             (g2 (normalize-goal (imply-g2 g) DNF?)))
        (if (and (listo? g1) (equal? v (listo-t g1)))
            (let* ((a (var/new 'a))
                   (base-case (substitute-term g2 v '()))
                   (antecedent g2)
                   (consequent (universal a (substitute-term g2 v (cons a v) DNF?)))
                   (inductive-step (universal v (imply antecedent (unfold consequent)))))
              (normalize-goal (conj base-case inductive-step) DNF?))
            (normalize-universal v (imply g1 g2) DNF? #f))))
    (else (let ((g (normalize-goal g DNF?)))
            (cond
              ((true? g)  (true))
              ((false? g) (false))
              ((==? g)    (if (or (term-use-var? (==-t1 g) v) (term-use-var? (==-t2 g) v)) (false) g))
              ((=/=? g)   (let ((t1 (=/=-t1 g)) (t2 (=/=-t2 g)))
                            (cond
                              ((or (equal? t1 v) (equal? t2 v)) (false))
                              ; ((or (term-use-var? t1 v) (term-use-var? t2 v)) (display "so bad: ") (display t1) (display " =/= ") (displayln t2) (false))
                              ((or (term-use-var? t1 v) (term-use-var? t2 v)) (false)) 
                              (else g))))
              
              ((or (typeo? g) (not-typeo? g)) (if (term-use-var? (typeo-t g) v) (false) g))
              
              ((imply? g)   (if (or (goal-use-var? (imply-g1 g) v) (goal-use-var? (imply-g2 g) v))
                                (error "Currently can't solve 1" g)
                                g))
              ((existential? g)  (if (goal-use-var? (existential-g g) v)
                                    (if (decidable? g) (error "Currently can't solve 2" g) (universal v g)) 
                                    g))
              ((universal? g) (let* ((h (universal-g g))
                                     (no-v-in-h? (not (goal-use-var? h v))))
                                (cond
                                  (no-v-in-h? (normalize-goal (negate-goal (normalize-goal (negate-goal h) DNF?)) DNF?))
                                  ((contains-equality-on-v? h v) (false))
                                  ((contains-disequality-on-v? h v) (false))
                                  ((decidable? g) (error "Currently can't solve 3" g))
                                  (else (universal v g)))))
              
                              ; (if (goal-use-var? (universal-g g) v)
                                  
                              ;     (if (decidable? g) (error "Currently can't solve 3" g) (universal v g))
                              ;     (normalize-goal (negate-goal (normalize-goal (negate-goal g) DNF?)) DNF?)))
              ((disj? g)    (let* ((g1 (disj-g1 g)) 
                                  (g2 (disj-g2 g))
                                  (no-v-in-g1? (not (goal-use-var? g1 v)))
                                  (no-v-in-g2? (not (goal-use-var? g2 v))))
                              (cond
                                ((and no-v-in-g1? no-v-in-g2?) (disj g1 g2))
                                (no-v-in-g1? (normalize-goal (disj g1 (universal v g2)) DNF?))
                                (no-v-in-g2? (normalize-goal (disj g2 (universal v g1)) DNF?))
                                ((contains-equality-on-v? g v) (false))
                                ((contains-typeo-on-v? g v #f) (false))
                                ((decidable? g) (normalize-goal (negate-goal (normalize-goal (negate-goal (universal v g)) DNF?)) DNF?)) ;;! WARNING: this may cause infinite recursion
                                (else (universal v g))))) ;(simplify (unfold g))))))   
              ((conj? g)    (let* ((g1 (conj-g1 g))
                                  (g2 (conj-g2 g))
                                  (no-v-in-g1? (not (goal-use-var? g1 v)))
                                  (no-v-in-g2? (not (goal-use-var? g2 v))))
                              (cond
                                ((and no-v-in-g1? no-v-in-g2?) (conj g1 g2))
                                (no-v-in-g1? (normalize-goal (conj g1 (universal v g2)) DNF?))
                                (no-v-in-g2? (normalize-goal (conj g2 (universal v g1)) DNF?))
                                (else (normalize-goal (conj (universal v g1) (universal v g2)) DNF?)))))
              ; ((and (relate? g) (equal? 'appendo (relate-name g)) (var? (car (relate-params g))))
              ;               (displayln "AHHHHH") (normalize-goal (universal v (imply (listo (car (relate-params g))) g))))
              (else         (universal v g)))))))

(define (combine-diseqs g)
  (match g
    ((disj (=/= t1 t2) (=/= s1 s2))           (=/= (cons t1 s1) (cons t2 s2)))
    ((disj (=/= t1 t2) (disj (=/= s1 s2) h))  (combine-diseqs (disj (=/= (cons t1 s1) (cons t2 s2)) h)))
    ((conj g1 g2)                             (conj (combine-diseqs g1) (combine-diseqs g2)))
    ((imply g1 g2)                            (imply (combine-diseqs g1) (combine-diseqs g2)))
    ((existential v h)                        (existential v (combine-diseqs h)))
    ((universal v h)                          (universal v (combine-diseqs h)))
    (_                                        g)))

(define (disj/conj? g)
  (or (disj? g) (conj? g)))

(define (disj/conj-g1 g)
  (if (disj? g)
      (disj-g1 g)
      (conj-g1 g)))

(define (disj/conj-g2 g)
  (if (disj? g)
      (disj-g2 g)
      (conj-g2 g)))

(define (typeo? g)
  (or (symbolo? g) (stringo? g) (numbero? g) (pairo? g) (listo? g)))

(define (not-typeo? g)
  (or (not-symbolo? g) (not-stringo? g) (not-numbero? g) (not-pairo? g) (not-listo? g)))

(define (typeo-t g)
  (match g
    ((symbolo t)      t)
    ((stringo t)      t)
    ((numbero t)      t)
    ((pairo t)        t)
    ((listo t)        t)
    ((not-symbolo t)  t)
    ((not-stringo t)  t)
    ((not-numbero t)  t)
    ((not-pairo t)    t)
    ((not-listo t)    t)
    (_ (error "typeo-t: invalid goal" g))))

(define (typeo->type? g)
  (match g
    ((symbolo _)      symbol?)
    ((not-symbolo _)  symbol?)
    ((stringo _)      string?)
    ((not-stringo _)  string?)
    ((numbero _)      number?)
    ((not-numbero _)  number?)
    ((pairo _)        pair?)
    ((not-pairo _)    pair?)
    ((listo _)        list?)
    ((not-listo _)    list?)
    (_ (error "type->type?: Invalid type" g))))

(define (type->goal t type? [not-type? #f])
  (cond
    ((and not-type? (eq? type? symbol?)) (not-symbolo t))
    ((eq? type? symbol?)                 (symbolo t))
    ((and not-type? (eq? type? string?)) (not-stringo t))
    ((eq? type? string?)                 (stringo t))
    ((and not-type? (eq? type? number?)) (not-numbero t))
    ((eq? type? number?)                 (numbero t))
    ((and not-type? (eq? type? pair?))   (not-pairo t))
    ((eq? type? pair?)                   (pairo t))
    ((and not-type? (eq? type? list?))   (not-listo t))
    ((eq? type? list?)                   (listo t))
    (else (error "type->goal: Invalid type"))))

(define (relate-name g)
  (match g
    ((relate _ des)     (car (cdr des)))
    ((not-relate _ des) (car (cdr des)))
    (_                  (error "relate-name: g is not a relate or not-relate" g))))

(define (relate-params g)
  (match g
    ((relate _ des)     (cdr (cdr des)))
    ((not-relate _ des) (cdr (cdr des)))
    (_                  (error "relate-params: g is not a relate or not-relate" g))))

(define (goal-use-var? g v)
  (match g
    ((true) #f)
    ((false) #f)
    ((disj g1 g2)       (or (goal-use-var? g1 v) (goal-use-var? g2 v)))
    ((conj g1 g2)       (or (goal-use-var? g1 v) (goal-use-var? g2 v)))
    ((== t1 t2)         (or (term-use-var? t1 v) (term-use-var? t2 v)))
    ((=/= t1 t2)        (or (term-use-var? t1 v) (term-use-var? t2 v)))
    ((imply g1 g2)      (or (goal-use-var? g1 v) (goal-use-var? g2 v)))
    ((existential _ h)  (goal-use-var? h v))
    ((universal _ h)    (goal-use-var? h v))
    ((relate _ des)     (term-use-var? des v))
    ((not-relate _ des) (term-use-var? des v))
    (_                  (if (or (typeo? g) (not-typeo? g))
                            (term-use-var? (typeo-t g) v)
                            (error "goal-use-var?: Can't check goal" g)))))

;; substitute v with term everywhere in g
(define (substitute-term g v term [DNF? #t])
  (match g
    ((true)             (true))
    ((false)            (false))
    ((disj g1 g2)       (normalize-goal (disj (substitute-term g1 v term DNF?) (substitute-term g2 v term DNF?))))
    ((conj g1 g2)       (normalize-goal (conj (substitute-term g1 v term DNF?) (substitute-term g2 v term DNF?))))
    ((== t1 t2)         (normalize-goal (== (term-replace t1 v term) (term-replace t2 v term))))
    ((=/= t1 t2)        (normalize-goal (=/= (term-replace t1 v term) (term-replace t2 v term))))
    ((imply g1 g2)      (normalize-goal (imply (substitute-term g1 v term DNF?) (substitute-term g2 v term DNF?))))
    ((existential q h)  (normalize-goal (existential q (substitute-term h v term DNF?))))
    ((universal q h)    (normalize-goal (universal q (substitute-term h v term DNF?))))
    ((relate _ des)     (if (goal-use-var? g v) (apply (car des) (map (lambda (arg) (if (equal? arg v) term arg)) (relate-params g))) g))
    ((not-relate _ des) (if (goal-use-var? g v) (negate-goal (apply (car des) (map (lambda (arg) (if (equal? arg v) term arg)) (relate-params g)))) g))
    (_                  (if (or (typeo? g) (not-typeo? g))
                            (normalize-goal (type->goal (if (equal? (typeo-t g) v) term (typeo-t g)) (typeo->type? g) (not-typeo? g)))
                            (error "substitute-term: Coudln't parse goal" g))))) 

(define (term-replace t v term)
  (if (pair? t)
      (cons (if (equal? (car t) v) term (car t)) (term-replace (cdr t) v term))
      (if (equal? t v) term t)))

(define (apply-type g v type? [DNF? #t] [not-type? #f])
  (match g
    ((true)             (true))
    ((false)            (false))
    ((disj g1 g2)       (normalize-goal (disj (apply-type g1 v type? DNF? not-type?) (apply-type g2 v type? DNF? not-type?))))
    ((conj g1 g2)       (normalize-goal (conj (apply-type g1 v type? DNF? not-type?) (apply-type g2 v type? DNF? not-type?))))
    ((== t1 t2)         (if (and (equal? v t2) (not (var? t1)) (eq? not-type? (type? t1)))
                            (false)
                            g))
    ((=/= t1 t2)        (if (and (equal? v t2) (not (var? t1)) (eq? not-type? (type? t1)))
                            (true)
                            g))
    ((imply g1 g2)      (normalize-goal (imply (apply-type g1 v type? DNF? not-type?) (apply-type g2 v type? DNF? not-type?))))
    ((existential q h)  (normalize-goal (existential q (apply-type h v type? DNF? not-type?))))
    ((universal q h)    (normalize-goal (universal q (apply-type h v type? DNF? not-type?))))
    (_                  (cond
                          ((and (typeo? g) (equal? v (typeo-t g)) (equal? (typeo->type? g) type?)) (if not-type? (false) (true)))
                          ((and (typeo? g) (equal? v (typeo-t g))) (if not-type? g (false)))
                          ((typeo? g) g)
                          ((and (not-typeo? g) (equal? v (typeo-t g)) (equal? (typeo->type? g) type?)) (if not-type? (true) (false)))
                          ((and (not-typeo? g) (equal? v (typeo-t g))) (if not-type? g (true)))
                          ((not-typeo? g) g)
                          (else g)))))

(define (goal=? g1 g2)    ;;* Assumes that g1 and g2 are normalized
  (match g1
    ((existential v h)  (and (existential? g2) (goal=? h (substitute-term (existential-g g2) (existential-v g2) v))))
    ((universal v h)    (and (universal? g2) (goal=? h (substitute-term (universal-g g2) (universal-v g2) v))))
    ((relate _ des)     (and (relate? g2) (equal? (relate-name g1) (relate-name g2)) (equal? (relate-params g1) (relate-params g2))))
    ((not-relate _ des) (and (not-relate? g2) (equal? (relate-name g1) (relate-name g2)) (equal? (relate-params g1) (relate-params g2))))
    (_                  (equal? g1 g2))))

(define (negation? g1 g2) ;;* Assumes that g1 and g2 are normalized
  (match g1
    ((disj _ _)         (and (conj? g2) (goal=? g1 (negate-goal g2)))) ;;! Due to the sorted orders of disj and conj being different in normalized form, this not always work
    ((conj _ _)         (and (disj? g2) (goal=? g1 (negate-goal g2)))) ;;! Due to the sorted orders of disj and conj being different in normalized form, this not always work
    ((imply h1 h2)      (and (imply? g2) (goal=? h1 (imply-g1 g2)) (negation? h2 (imply-g2 g2))))
    ((existential v h)  (and (universal? g2) (negation? h (substitute-term (universal-g g2) (universal-v g2) v))))
    ((universal v h)    (and (existential? g2) (negation? h (substitute-term (existential-g g2) (existential-v g2) v))))
    ((relate _ _)       (and (not-relate? g2) (goal=? g1 (negate-goal g2))))
    (_                  (and (not (or (disj/conj? g2) (imply? g2) (existential? g2) (universal? g2) (relate? g2))) (goal=? g1 (negate-goal g2))))))

(define (contains-equality-on-v? g v)
  (match g
    ((== t1 t2)   (or (equal? t1 v) (equal? t2 v)))
    ((conj g1 g2) (or (contains-equality-on-v? g1 v) (contains-equality-on-v? g2 v)))
    ((disj g1 g2) (and (contains-equality-on-v? g1 v) (contains-equality-on-v? g2 v)))    
    ((existential _ h) (contains-equality-on-v? h v))
    ((universal _ h)  (contains-equality-on-v? h v))
    (_ #f)))

(define (contains-disequality-on-v? g v)
  (match g
    ((=/= t1 t2)  (or (equal? t1 v) (equal? t2 v)))
    ((conj g1 g2) (or (contains-disequality-on-v? g1 v) (contains-disequality-on-v? g2 v)))
    ((disj g1 g2) (and (contains-disequality-on-v? g1 v) (contains-disequality-on-v? g2 v)))    
    ((existential _ h) (contains-disequality-on-v? h v))
    ((universal _ h)  (contains-disequality-on-v? h v))
    (_ #f)))

(define (contains-typeo-on-v? g v [not-type? #f])
  (match g
    ((conj g1 g2) (or (contains-typeo-on-v? g1 v not-type?) (contains-typeo-on-v? g2 v not-type?)))
    ((disj g1 g2) (and (contains-typeo-on-v? g1 v not-type?) (contains-typeo-on-v? g2 v not-type?)))
    ((existential _ h) (contains-typeo-on-v? h v not-type?))
    ((universal _ h)  (contains-typeo-on-v? h v not-type?))
    (_  (if not-type?
            (and (not-typeo? g) (equal? (typeo-t g) v))
            (and (typeo? g) (equal? (typeo-t g) v))))))

(define (replace-assumption-with-true ant con)
  (if (goal=? ant con)
      (true)
      (match con
        ((disj g1 g2)       (disj (replace-assumption-with-true ant g1) (replace-assumption-with-true ant g2)))
        ((conj g1 g2)       (conj (replace-assumption-with-true ant g1) (replace-assumption-with-true ant g2)))
        ((imply g1 g2)      (imply (replace-assumption-with-true ant g1) (replace-assumption-with-true ant g2)))
        ((existential v h)  (existential v (replace-assumption-with-true ant h)))
        ((universal v h)    (universal v (replace-assumption-with-true ant h)))
        (_                  con))))

(define (goal<? g1 g2)
  (eqv? (goal-compare g1 g2) -1))

(define (goal-diseq-first<? g1 g2)
  (eqv? (goal-diseq-first-compare g1 g2) -1))

(define (goal-compare g1 g2)
  (cond
    ((true? g1)         -1)
    ((true? g2)         1)
    ((false? g1)        -1)
    ((false? g2)        1)
    ((==? g1)           (cond
                          ((and (==? g2) (equal? (==-t1 g1) (==-t1 g2))) (term-compare (==-t2 g1) (==-t2 g2)))
                          ((==? g2) (term-compare (==-t1 g1) (==-t1 g2)))
                          (else -1)))
    ((==? g2)           1)
    ((symbolo? g1)      (if (symbolo? g2) (term-compare (symbolo-t g1) (symbolo-t g2)) -1))
    ((symbolo? g2)      1)
    ((stringo? g1)      (if (stringo? g2) (term-compare (stringo-t g1) (stringo-t g2)) -1))
    ((stringo? g2)      1)
    ((numbero? g1)      (if (numbero? g2) (term-compare (numbero-t g1) (numbero-t g2)) -1))
    ((numbero? g2)      1)
    ((pairo? g1)        (if (pairo? g2) (term-compare (pairo-t g1) (pairo-t g2)) -1))
    ((pairo? g2)        1)
    ((listo? g1)        (if (listo? g2) (term-compare (listo-t g1) (listo-t g2)) -1))
    ((listo? g2)        1)
    ((not-symbolo? g1)  (if (not-symbolo? g2) (term-compare (not-symbolo-t g1) (not-symbolo-t g2)) -1))
    ((not-symbolo? g2)  1)
    ((not-stringo? g1)  (if (not-stringo? g2) (term-compare (not-stringo-t g1) (not-stringo-t g2)) -1))
    ((not-stringo? g2)  1)
    ((not-numbero? g1)  (if (not-numbero? g2) (term-compare (not-numbero-t g1) (not-numbero-t g2)) -1))
    ((not-numbero? g2)  1)
    ((not-pairo? g1)    (if (not-pairo? g2) (term-compare (not-pairo-t g1) (not-pairo-t g2)) -1))
    ((not-pairo? g2)    1)
    ((not-listo? g1)    (if (not-listo? g2) (term-compare (not-listo-t g1) (not-listo-t g2)) -1))
    ((not-listo? g2)    1)
    ((=/=? g1)          (cond
                          ((and (=/=? g2) (equal? (=/=-t1 g1) (=/=-t1 g2))) (term-compare (=/=-t2 g1) (=/=-t2 g2)))
                          ((=/=? g2) (term-compare (=/=-t1 g1) (=/=-t1 g2)))
                          (else -1)))
    ((=/=? g2)          1)
    ((imply? g1)        (if (imply? g2)
                            (let ((compared-g1 (goal-compare (imply-g1 g1) (imply-g1 g2))))
                              (if (eqv? 0 compared-g1) (goal-compare (imply-g2 g1) (imply-g2 g2)) compared-g1))
                            -1))
    ((imply? g2)        1)
    ((existential? g1)       (if (existential? g2) (if (< (var-index (existential-v g1)) (var-index (existential-v g2))) -1 1) -1))
    ((existential? g2)       1)
    ((universal? g1)      (if (universal? g2) (if (< (var-index (universal-v g1)) (var-index (universal-v g2))) -1 1) -1))
    ((universal? g2)      1)
    ((conj? g1)         (if (conj? g2)
                            (let ((compared-g1 (goal-compare (conj-g1 g1) (conj-g1 g2))))
                              (if (eqv? compared-g1 0) 
                                  (goal-compare (conj-g2 g1) (conj-g2 g2)) 
                                  compared-g1))
                            -1))
    ((conj? g2)         1)
    ((disj? g1)         (if (disj? g2)
                            (let ((compared-g1 (goal-compare (disj-g1 g1) (disj-g1 g2))))
                              (if (eqv? compared-g1 0) 
                                  (goal-compare (disj-g2 g1) (disj-g2 g2)) 
                                  compared-g1))
                            -1))
    ((disj? g2)         1)
    ((relate? g1)       (if (relate? g2) (term-compare (cdr (relate-description g1)) (cdr (relate-description g2))) -1))
    ((relate? g2)       1)
    ((not-relate? g1)   (if (not-relate? g2) (term-compare (cdr (not-relate-description g1)) (cdr (not-relate-description g2))) -1))
    ((not-relate? g2)   1)
    (else               0)))

(define (goal-diseq-first-compare g1 g2)
  (cond
    ((true? g1)         -1)
    ((true? g2)         1)
    ((false? g1)        -1)
    ((false? g2)        1)
    ((=/=? g1)          (cond
                          ((and (=/=? g2) (equal? (=/=-t1 g1) (=/=-t1 g2))) (term-compare (=/=-t2 g1) (=/=-t2 g2)))
                          ((=/=? g2) (term-compare (=/=-t1 g1) (=/=-t1 g2)))
                          (else -1)))
    ((=/=? g2)          1)
    ((not-listo? g1)    (if (not-listo? g2) (term-compare (not-listo-t g1) (not-listo-t g2)) -1))
    ((not-listo? g2)    1)
    ((not-pairo?   g1)  (if (not-pairo? g2) (term-compare (not-pairo-t g1) (not-pairo-t g2)) -1))
    ((not-pairo?   g2)  1)
    ((not-numbero? g1)  (if (not-numbero? g2) (term-compare (not-numbero-t g1) (not-numbero-t g2)) -1))
    ((not-numbero? g2)  1)
    ((not-stringo? g1)  (if (not-stringo? g2) (term-compare (not-stringo-t g1) (not-stringo-t g2)) -1))
    ((not-stringo? g2)  1)
    ((not-symbolo? g1)  (if (not-symbolo? g2) (term-compare (not-symbolo-t g1) (not-symbolo-t g2)) -1))
    ((not-symbolo? g2)  1)
    ((listo? g1)        (if (listo? g2) (term-compare (listo-t g1) (listo-t g2)) -1))
    ((listo? g2)        1)
    ((pairo?   g1)      (if (pairo? g2) (term-compare (pairo-t g1) (pairo-t g2)) -1))
    ((pairo?   g2)      1)
    ((numbero? g1)      (if (numbero? g2) (term-compare (numbero-t g1) (numbero-t g2)) -1))
    ((numbero? g2)      1)
    ((stringo? g1)      (if (stringo? g2) (term-compare (stringo-t g1) (stringo-t g2)) -1))
    ((stringo? g2)      1)
    ((symbolo? g1)      (if (symbolo? g2) (term-compare (symbolo-t g1) (symbolo-t g2)) -1))
    ((symbolo? g2)      1)
    ((==? g1)           (cond
                          ((and (==? g2) (equal? (==-t1 g1) (==-t1 g2))) (term-compare (==-t2 g1) (==-t2 g2)))
                          ((==? g2) (term-compare (==-t1 g1) (==-t1 g2)))
                          (else -1)))
    ((==? g2)           1)
    (else               (goal-compare g1 g2))))