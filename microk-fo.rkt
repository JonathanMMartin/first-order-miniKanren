#lang racket
(provide
  (all-from-out "common.rkt")
  (struct-out disj)
  (struct-out conj)
  (struct-out relate)
  (struct-out ==)
  (struct-out =/=)
  (struct-out symbolo)
  (struct-out stringo)
  (struct-out numbero)
  (struct-out not-symbolo)
  (struct-out not-stringo)
  (struct-out not-numbero)
  (struct-out imply)
  (struct-out existo)
  (struct-out forallo)
  (struct-out mplus)
  (struct-out bind)
  (struct-out pause)
  step
  mature
  mature?
  normalize-goal)

(require "common.rkt")

;; first-order microKanren
(struct true     ()                      #:prefab)
(struct false    ()                      #:prefab)
(struct disj    (g1 g2)                  #:prefab)
(struct conj    (g1 g2)                  #:prefab)
(struct relate  (thunk description)      #:prefab)
(struct ==      (t1 t2)                  #:prefab)
(struct =/=     (t1 t2)                  #:prefab)
(struct symbolo (t)                      #:prefab)
(struct stringo (t)                      #:prefab)
(struct numbero (t)                      #:prefab)
(struct not-symbolo (t)                  #:prefab)
(struct not-stringo (t)                  #:prefab)
(struct not-numbero (t)                  #:prefab)
(struct imply   (g1 g2)                  #:prefab)
(struct existo  (vlst g)                 #:prefab)
(struct forallo (v g)                 #:prefab)
(struct bind    (bind-s bind-g)          #:prefab)
(struct mplus   (mplus-s1 mplus-s2)      #:prefab)
(struct pause   (pause-state pause-goal) #:prefab)

(define (mature? s) (or (not s) (pair? s)))
(define (mature s)
  (if (mature? s) s (mature (step s))))

;; Implication
(define (negate-goal g)
  (match g
    ((true)  (false))
    ((false) (true))
    ((conj g1 g2) (disj (negate-goal g1) (negate-goal g2)))
    ((disj g1 g2) (conj (negate-goal g1) (negate-goal g2)))
    ((== t1 t2) (=/= t1 t2))
    ((=/= t1 t2) (== t1 t2))
    ((symbolo t) (not-symbolo t))
    ((stringo t) (not-stringo t))
    ((numbero t) (not-numbero t))
    ((not-symbolo t) (symbolo t))
    ((not-stringo t) (stringo t))
    ((not-numbero t) (numbero t))
    ((imply g1 g2) (conj g1 (negate-goal g2)))
    ((existo vlst g) (forallo (first vlst) (negate-goal g))) ;; TODO: MAJOR HACK PLS FIX
    ((forallo v g) (existo (list v) (negate-goal g)))
    (_ (error "unnegateable goal" g))
    ))

(define (state->goal st)
  (let* ((sub (state-sub st))
         (diseq (state-diseq st))
         (types (state-types st))
         (not-types (state-not-types st)))
    (sub->goal sub (true))))

(define (sub->goal sub acc)
  (match sub
    ('() acc)
    ((cons (cons x y) rest) (sub->goal rest (conj (== x y) acc)))))

(define (types->goal types acc)
  (match types
    ('() acc)
    ((cons (cons v type?) rest) (types->goal rest (conj type->goal-helper v type?) acc))))

(define (type->goal-helper u type?)
  (cond
    ((eq? type? symbol?) (symbolo u))
    ((eq? type? string?) (stringo u))
    ((eq? type? number?) (numbero u))
    (error "Invalid type")))

(define (goal-use-var? g v)
  (match g
    ((true)  #f)
    ((false) #f)
    ((conj g1 g2) (or (goal-use-var? g1 v) (goal-use-var? g2 v)))
    ((disj g1 g2) (or (goal-use-var? g1 v) (goal-use-var? g2 v)))
    ((== t1 t2) (or (term-use-var? t1 v) (term-use-var? t2 v)))
    ((=/= t1 t2) (or (term-use-var? t1 v) (term-use-var? t2 v)))
    ((symbolo t) (term-use-var? t v))
    ((stringo t) (term-use-var? t v))
    ((numbero t) (term-use-var? t v))
    ((not-symbolo t) (term-use-var? t v))
    ((not-stringo t) (term-use-var? t v))
    ((not-numbero t) (term-use-var? t v))
    ((imply g1 g2) (or (goal-use-var? g1 v) (goal-use-var? g2 v)))
    ((existo xlst g) (goal-use-var? g v))
    ((forallo x g) (goal-use-var? g v))
    (_ (error "can't check goal" g))
    ))

;; IDEA: have sorted order for terms, ie literal first (== then =/= then typo then not-typo), then conj then forall (or something like that)

(define (normalize-goal-forall v g)
  (match (normalize-goal g)
    ((false) (false))
    ((true) (true))
    ((== t1 t2) (if (or (term-use-var? t1 v) (term-use-var? t2 v))
                    (false)
                    (== t1 t2)))
    ((=/= t1 t2) (if (or (term-use-var? t1 v) (term-use-var? t2 v))
                    (false)
                    (=/= t1 t2)))
    ((symbolo t) (if (term-use-var? t v)
                     (false)
                     (symbolo t)))
    ((stringo t) (if (term-use-var? t v)
                     (false)
                     (stringo t)))
    ((numbero t) (if (term-use-var? t v)
                     (false)
                     (numbero t)))
    ((not-symbolo t) (if (term-use-var? t v)
                     (false)
                     (not-symbolo t)))
    ((not-stringo t) (if (term-use-var? t v)
                     (false)
                     (not-stringo t)))
    ((not-numbero t) (if (term-use-var? t v)
                     (false)
                     (not-numbero t)))
    ((disj g1 g2) (let* ((g1 (normalize-goal g1))
                         (g2 (normalize-goal g2))
                         (g1-v? (goal-use-var? g1 v))
                         (g2-v? (goal-use-var? g2 v)))
                    (cond
                      ((and (not g1-v?) (not g2-v?)) (disj g1 g2))
                      ((not g1-v?) (normalize-goal (disj g1 (forallo v g2))))
                      ((not g2-v?) (normalize-goal (disj g2 (forallo v g1))))
                      (else (forallo v (disj g1 g2))))))
    ((conj g1 g2) (let* ((g1 (normalize-goal g1))
                         (g2 (normalize-goal g2))
                         (g1-v? (goal-use-var? g1 v))
                         (g2-v? (goal-use-var? g2 v)))
                    (cond
                      ((and (not g1-v?) (not g2-v?)) (conj g1 g2))
                      ((not g1-v?) (normalize-goal (conj g1 (forallo v g2))))
                      ((not g2-v?) (normalize-goal (conj g2 (forallo v g1))))
                      (else (forallo v (conj g1 g2))))))
    ))

(define (vacuous-disj-conj? g negated-first-goal)
  (match g
    ((disj g1 g2) (or (equal? g1 negated-first-goal) (vacuous-disj-conj? g2 negated-first-goal)))
    ((conj g1 g2) (or (equal? g1 negated-first-goal) (vacuous-disj-conj? g2 negated-first-goal)))
    (h (equal? h negated-first-goal))))

;; g1 guarantees a single goal g2 holds
;; g1 must be normalized conj
(define (conj-subsumes-single g1 g2)
  (match g1
    ((conj h1 h2) (or (equal? h1 g2) (conj-subsumes-single h2 g2)))
    (h (equal? h g2))))

;; g1 guarantees all goals in g2 hold
;; g1 and g2 must be normalized conjs
(define (conj-subsumes g1 g2)
  (match g2
    ((conj h1 h2) (and (conj-subsumes-single g1 h1) (conj-subsumes g1 h2)))
    (h (conj-subsumes-single g1 h))))

;; substitute v with term t everywhere in g
(define (substitute-term g v term)
  (match g
    ((true)  (true))
    ((false) (false))
    ((conj g1 g2) (conj (substitute-term g1 v term) (substitute-term g2 v term)))
    ((disj g1 g2) (disj (substitute-term g1 v term) (substitute-term g2 v term)))
    ((== t1 t2) (cond
                  ((equal? t1 v) (== term t2))
                  ((equal? t2 v) (== t1 term))
                  (else (== t1 t2))))
    ((=/= t1 t2) (cond
                  ((equal? t1 v) (=/= term t2))
                  ((equal? t2 v) (=/= t1 term))
                  (else (=/= t1 t2))))
    ((symbolo t) (symbolo (if (equal? t v) term t)))
    ((stringo t) (stringo (if (equal? t v) term t)))
    ((numbero t) (numbero (if (equal? t v) term t)))
    ((not-symbolo t) (not-symbolo (if (equal? t v) term t)))
    ((not-stringo t) (not-stringo (if (equal? t v) term t)))
    ((not-numbero t) (not-numbero (if (equal? t v) term t)))
    ((imply g1 g2) (imply (substitute-term g1 v term) (substitute-term g2 v term)))
    ((existo xlst g) (existo xlst (substitute-term g v term)))
    ((forallo x g) (forallo x (substitute-term g v term)))
    (_ (error "couldn't parse goal" g))
    ))

(define/match (normalize-goal g)

  ;; remove lists/pairs
  ; (((== (cons f1 r1) (cons f2 r2))) (normalize-goal (conj (== f1 f2) (== r1 r2))))
  ; (((== (cons f1 r1) t2)) (if (var? t2) (== (cons f1 r1) t2) (false)))
  ; (((== t1 (cons f2 r2))) (if (var? t1) (== (cons f2 r2) t1) (false)))
  
  ; (((=/= (cons f1 r1) (cons f2 r2))) (normalize-goal (disj (=/= f1 f2) (=/= r1 r2))))
  ; (((=/= (cons f1 r1) t2)) (if (var? t2) (=/= (cons f1 r1) t2) (false)))
  ; (((=/= t1 (cons f2 r2))) (if (var? t1) (=/= (cons f2 r2) t1) (false)))

  ;; basic things
  (((== t1 t2))           (cond
                            ((equal? t1 t2) (true))
                            ((and (var? t1) (var? t2)) (if (< (var-index t1) (var-index t2)) (== t1 t2) (== t2 t1)))
                            ((var? t2) (== t1 t2))
                            ((var? t1) (== t2 t1))
                            ((contains-fresh? t2) (== t1 t2))
                            ((contains-fresh? t1) (== t2 t1))
                            (else (false))))
  (((=/= t1 t2))          (cond
                            ((equal? t1 t2) (false))
                            ((and (var? t1) (var? t2)) (if (< (var-index t1) (var-index t2)) (=/= t1 t2) (=/= t2 t1)))
                            ((var? t2) (=/= t1 t2))
                            ((var? t1) (=/= t2 t1))
                            ((contains-fresh? t2) (=/= t1 t2))
                            ((contains-fresh? t1) (=/= t2 t1))
                            (else (true))))
  (((symbolo t))          (if (var? t) g (if (symbol? t) (true) (false))))
  (((stringo t))          (if (var? t) g (if (string? t) (true) (false))))
  (((numbero t))          (if (var? t) g (if (number? t) (true) (false))))
  (((not-symbolo t))      (if (var? t) g (if (symbol? t) (false) (true))))
  (((not-stringo t))      (if (var? t) g (if (string? t) (false) (true))))
  (((not-numbero t))      (if (var? t) g (if (number? t) (false) (true))))
  (((disj (true) _))      (true))
  (((disj _ (true)))      (true))
  (((disj (false) g))     (normalize-goal g))
  (((disj g (false)))     (normalize-goal g))
  (((conj (true) g))      (normalize-goal g))
  (((conj g (true)))      (normalize-goal g))
  (((conj (false) _))     (false))
  (((conj _ (false)))     (false))
  (((imply (true) g))     (normalize-goal g))
  (((imply (false) _))    (true))
  (((existo _ (true)))    (true))
  (((existo _ (false)))   (false))
  (((forallo _ (true)))   (true))
  (((forallo _ (false)))  (false))

  ;; imply => disj
  (((imply g1 g2)) (normalize-goal (disj (negate-goal g1) g2)))

  (((existo vlst g)) (existo vlst (normalize-goal g)))
  
  ;; DNF for disj
  (((disj (disj g1 g2) g3))
    (normalize-goal (disj g1 (disj g2 g3))))
  (((disj g1 g2)) ;; use sorted order here if g1 < g2, then (disj g1 g2) else (disj g2 g1)
    (let ((h1 (normalize-goal g1))
          (h2 (normalize-goal g2)))
      (cond ((equal? h1 h2) h1)
            ; ((equal? h1 (negate-goal h2)) (true))
            ((and (equal? g1 h1) (equal? g2 h2)) (cond
                                                   ((vacuous-disj-conj? h2 (negate-goal h1)) (true))
                                                   ((and (conj? h1) (conj? h2) (conj-subsumes h1 h2)) (normalize-goal h2))
                                                   ((and (conj? h1) (conj? h2) (conj-subsumes h2 h1)) (normalize-goal h1))
                                                   (else (disj h1 h2))))
            ;((and (equal? g1 h1) (equal? g2 h2)) (if (goal<? h1 h2) (disj h1 h2) (disj h2 h1)))
            (else (normalize-goal (disj h1 h2))))))
            ;(else (if (goal<? h1 h2) (normalize-goal (disj h1 h2)) (normalize-goal (disj h2 h1)))))))
  
  ;; DNF for conj
  (((conj (conj g1 g2) g3))
    (normalize-goal (conj g1 (conj g2 g3))))
  (((conj (disj g1 g2) g3))
    (normalize-goal (disj (conj g1 g3) (conj g2 g3))))
  (((conj g1 (disj g2 g3)))
    (normalize-goal (disj (conj g1 g2) (conj g1 g3))))
  (((conj g1 g2))
    (let ((h1 (normalize-goal g1))
          (h2 (normalize-goal g2)))
      (cond ((equal? h1 h2) h1)
            ((and (equal? g1 h1) (equal? g2 h2)) (cond
                                                   ((vacuous-disj-conj? h2 (negate-goal h1)) (false))
                                                   ((and (conj? h2) (==? (conj-g1 h2)) (not (contains-fresh? (==-t1 (conj-g1 h2)))) (or (not (==? h1)) (contains-fresh? (==-t1 h1))))
                                                     (normalize-goal (conj h2 h1)))
                                                   ((and (==? h1) (not (contains-fresh? (==-t1 h1))))
                                                     (let ((h3 (substitute-term h2 (==-t2 h1) (==-t1 h1))))
                                                       (if (equal? h3 h2) (conj h1 h2) (normalize-goal (conj h1 h3)))))
                                                   (else (conj h1 h2)))) ;; use sorted order here if g1 < g2, then (disj g1 g2) else (disj g2 g1)
            ;((and (equal? g1 h1) (equal? g2 h2)) (if (goal<? h1 h2) (conj h1 h2) (conj h2 h1)))
            (else (normalize-goal (conj h1 h2))))))
            ;(else (if (goal<? h1 h2) (normalize-goal (conj h1 h2)) (normalize-goal (conj h2 h1)))))))
  
  ;; forall rules
  (((forallo v g))
    (normalize-goal-forall v g))

  ;; no simplifications
  ((g) g))

(define (start st g)
  (match (normalize-goal g)
    ((true) (state->stream st))
    ((false) (state->stream #f))
    ((disj g1 g2)
     (step (mplus (pause st g1)
                  (pause st g2))))
    ((conj g1 g2)
     (step (bind (pause st g1) g2)))
    ((relate thunk _)
     (pause st (thunk)))
    ((== t1 t2) (state->stream (unify t1 t2 st)))
    ((=/= t1 t2) (state->stream (disunify t1 t2 st)))
    ((symbolo t) (state->stream (typify t symbol? st)))
    ((stringo t) (state->stream (typify t string? st)))
    ((numbero t) (state->stream (typify t number? st)))
    ((not-symbolo t) (state->stream (not-typify t symbol? st)))
    ((not-stringo t) (state->stream (not-typify t string? st)))
    ((not-numbero t) (state->stream (not-typify t number? st)))
    ((imply g1 g2)
     (step (mplus (pause st (negate-goal g1))
                  (pause st (conj g1 g2)))))
    ((existo vlst g) (step (pause (extend-scope-multi vlst 'e st) g))) ; TODO change to single variable
    ((forallo v g) (error "not enough rules: forall"))
    ))

(define (step s)
  (match s
    ((mplus s1 s2)
     (let ((s1 (if (mature? s1) s1 (step s1))))
       (cond ((not s1) s2)
             ((pair? s1)
              (cons (car s1)
                    (mplus s2 (cdr s1))))
             (else (mplus s2 s1)))))
    ((bind s g)
     (let ((s (if (mature? s) s (step s))))
       (cond ((not s) #f)
             ((pair? s)
              (step (mplus (pause (car s) g)
                           (bind (cdr s) g))))
             (else (bind s g)))))
    ((pause st g) (start st g))
    (_            s)))

;; TODO: Fix the sorting order, weird stuff happens when we use it.
;;       I think the problem is when we try to compare two goals of the same type ie. == to ==
(define (goal<? g1 g2)
  (cond
    ((equal? g1 g2)     #f)
    ((true? g1)         #t)
    ((true? g2)         #f)
    ((false? g1)        #t)
    ((false? g2)        #f)
    ((==? g1)           (if (==? g2) #f #t))
    ((==? g2)           #f)
    ((=/=? g1)          (if (=/=? g2) #f #t))
    ((=/=? g2)          #f)
    ((symbolo? g1)      (if (symbolo? g2) #f #t))
    ((symbolo? g2)      #f)
    ((stringo? g1)      (if (stringo? g2) #f #t))
    ((stringo? g2)      #f)
    ((numbero? g1)      (if (numbero? g2) #f #t))
    ((numbero? g2)      #f)
    ((not-symbolo? g1)  (if (not-symbolo? g2) #f #t))
    ((not-symbolo? g2)  #f)
    ((not-stringo? g1)  (if (not-stringo? g2) #f #t))
    ((not-stringo? g2)  #f)
    ((imply? g1)        (if (imply? g2) #f #t))
    ((imply? g2)        #f)
    ((existo? g1)       (if (existo? g2) #f #t))
    ((existo? g2)       #f)
    ((forallo? g1)      (if (forallo? g2) #f #t))
    ((forallo? g2)      #f)
    ((conj? g1)         (if (conj? g2) #f #t))
    ((conj? g2)         #f)
    ((disj? g1)         #f)
    ((disj? g2)         #t)
    (else               #f)))