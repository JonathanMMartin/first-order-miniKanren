#lang racket
(provide
  (all-from-out "common.rkt")
  (struct-out disj)
  (struct-out conj)
  (struct-out relate)
  (struct-out ==)
  (struct-out =/=)
  (struct-out symbolo)
  (struct-out stringo)
  (struct-out numbero)
  (struct-out not-symbolo)
  (struct-out not-stringo)
  (struct-out not-numbero)
  (struct-out imply)
  (struct-out existo)
  (struct-out forallo)
  (struct-out mplus)
  (struct-out bind)
  (struct-out pause)
  step
  mature
  mature?
  normalize-goal)

(require "common.rkt")

;; first-order microKanren
(struct true     ()                      #:prefab)
(struct false    ()                      #:prefab)
(struct disj    (g1 g2)                  #:prefab)
(struct conj    (g1 g2)                  #:prefab)
(struct relate  (thunk description)      #:prefab)
(struct ==      (t1 t2)                  #:prefab)
(struct =/=     (t1 t2)                  #:prefab)
(struct symbolo (t)                      #:prefab)
(struct stringo (t)                      #:prefab)
(struct numbero (t)                      #:prefab)
(struct not-symbolo (t)                  #:prefab)
(struct not-stringo (t)                  #:prefab)
(struct not-numbero (t)                  #:prefab)
(struct imply   (g1 g2)                  #:prefab)
(struct existo  (vlst g)                 #:prefab)
(struct forallo (vlst g)                 #:prefab)
(struct bind    (bind-s bind-g)          #:prefab)
(struct mplus   (mplus-s1 mplus-s2)      #:prefab)
(struct pause   (pause-state pause-goal) #:prefab)

(define (mature? s) (or (not s) (pair? s)))
(define (mature s)
  (if (mature? s) s (mature (step s))))

;; Implication
(define (negate-goal g)
  (match g
    ((true)  (false))
    ((false) (true))
    ((conj g1 g2) (disj (negate-goal g1) (negate-goal g2)))
    ((disj g1 g2) (conj (negate-goal g1) (negate-goal g2)))
    ((== t1 t2) (=/= t1 t2))
    ((=/= t1 t2) (== t1 t2))
    ((symbolo t) (not-symbolo t))
    ((stringo t) (not-stringo t))
    ((numbero t) (not-numbero t))
    ((not-symbolo t) (symbolo t))
    ((not-stringo t) (stringo t))
    ((not-numbero t) (numbero t))
    ((imply g1 g2) (conj g1 (negate-goal g2)))
    ((existo vlst g) (forallo vlst (negate-goal g)))
    ((forallo vlst g) (existo vlst (negate-goal g)))
    (_ (error "unnegateable goal" g))
    ))

(define (state->goal st)
  (let* ((sub (state-sub st))
         (diseq (state-diseq st))
         (types (state-types st))
         (not-types (state-not-types st)))
    (sub->goal sub (true))))

(define (sub->goal sub acc)
  (match sub
    ('() acc)
    ((cons (cons x y) rest) (sub->goal rest (conj (== x y) acc)))))

(define (types->goal types acc)
  (match types
    ('() acc)
    ((cons (cons v type?) rest) (types->goal rest (conj type->goal-helper v type?) acc))))

(define (type->goal-helper u type?)
  (cond
    ((eq? type? symbol?) (symbolo u))
    ((eq? type? string?) (stringo u))
    ((eq? type? number?) (numbero u))
    (error "Invalid type")))

; (define (start st g)
;   (match g
;     ((true) (state->stream st))
;     ((false) (state->stream #f))
;     ((disj g1 g2)
;      (step (mplus (pause st g1)
;                   (pause st g2))))
;     ((conj g1 g2)
;      (step (bind (pause st g1) g2)))
;     ((relate thunk _)
;      (pause st (thunk)))
;     ((== t1 t2) (state->stream (unify t1 t2 st)))
;     ((=/= t1 t2) (state->stream (disunify t1 t2 st)))
;     ((symbolo t) (state->stream (typify t symbol? st)))
;     ((stringo t) (state->stream (typify t string? st)))
;     ((numbero t) (state->stream (typify t number? st)))
;     ((not-symbolo t) (state->stream (not-typify t symbol? st)))
;     ((not-stringo t) (state->stream (not-typify t string? st)))
;     ((not-numbero t) (state->stream (not-typify t number? st)))
;     ((imply g1 g2)
;      (step (mplus (pause st (negate-goal g1))
;                   (pause st (conj g1 g2)))))
;     ; ((forallo v (imply g1 g2))
;     ;  (let ((candidates (step (pause st (conj g1 g2)))))
;     ;   (if candidates
;     ;       (error "There are more candidates in the implies")
;     ;       (error "forall failed, no candidates"))))
;     ((existo vlst g) (step (pause (extend-scope-multi vlst 'e st) g))) ; TODO change to single variable
;     ((forallo vlst g)
;      (let* ((v (first vlst))
;             (candidates (step (pause st (existo vlst g))))
;             (can (and candidates (step candidates))) ; TODO this was a hack, still doesn't work
;             (can (and can (car can)))
;             (st (extend-scope-multi vlst 'u st)))
;         (and can
;              (let* ((v-state (get-constraints can v))
;                     (v-goal (state->goal v-state)))
;                 (if (true? v-goal)
;                     (state->stream can)
;                     (if (state=? (remove-initial can) v-state)
;                         (pause st (forallo vlst (conj (negate-goal v-goal) g)))
;                         (pause st (forallo vlst (imply (negate-goal v-goal) g)))))))))
;     ))

;; IDEA: have sorted order for terms, ie literal first (== then =/= then typo then not-typo), then conj then forall (or something like that)

(define/match (normalize-goal g)
  (((==  t1 t2))          (if (equal? t1 t2) (true) g))   ;; TODO: handle case where t1 or t2 are vars, or are lists containing vars.
  (((=/= t1 t2))          (if (equal? t1 t2) (false) g))  ;; TODO: handle case where t1 or t2 are vars, or are lists containing vars.
  (((symbolo t))          (if (var? t) g (if (symbol? t) (true) (false))))
  (((stringo t))          (if (var? t) g (if (string? t) (true) (false))))
  (((numbero t))          (if (var? t) g (if (number? t) (true) (false))))
  (((not-symbolo t))      (if (var? t) g (if (symbol? t) (false) (true))))
  (((not-stringo t))      (if (var? t) g (if (string? t) (false) (true))))
  (((not-numbero t))      (if (var? t) g (if (number? t) (false) (true))))
  (((disj (true) _))      (true))
  (((disj _ (true)))      (true))
  (((disj (false) g))     (normalize-goal g))
  (((disj g (false)))     (normalize-goal g))
  (((conj (true) g))      (normalize-goal g))
  (((conj g (true)))      (normalize-goal g))
  (((conj (false) _))     (false))
  (((conj _ (false)))     (false))
  (((imply (true) g1))    (normalize-goal g1))
  (((imply (false) _))    (true))
  (((existo _ (true)))    (true))
  (((existo _ (false)))   (false))
  (((forallo _ (true)))   (true))
  (((forallo _ (false)))  (false))
  (((disj (disj g1 g2) g3))
    (normalize-goal (disj g1 (disj g2 g3))))
  ;(((disj (conj g1 g2) (conj g3 g4)))
  ;  (let ((g1 (normalize-goal (conj g1 g2)))
  ;        (g2 (normalize-goal (conj g3 g4))))
  ;    (if (equal? g1 g2)
  ;        g1
  ;        (disj g1 g2))))
  (((disj (conj g1 g2) g3))
    (match (normalize-goal (conj g1 g2))
      ((disj h1 h2) (normalize-goal (disj h1 (disj h2 g3))))
      (h (disj h (normalize-goal g3)))))
    ;(match (normalize-goal g3)
    ;  ((disj h1 h2) (normalize-goal (disj h1 (disj h2 (conj g1 g2)))))
    ;  (h (normalize-goal (disj h (conj g1 g2))))))
  (((disj g1 g2))
    (let ((g1 (normalize-goal g1))
          (g2 (normalize-goal g2)))
      (if (equal? g1 g2)
          g1
          (disj g1 g2)))) ;; use sorted order here if g1 < g2, then (disj g1 g2) else (disj g2 g1)
  
  (((conj (conj g1 g2) g3))
    (normalize-goal (conj g1 (conj g2 g3))))
  (((conj (disj g1 g2) g3))
    (normalize-goal (disj (conj g1 g3) (conj g2 g3))))
  (((conj g1 (disj g2 g3)))
    (normalize-goal (disj (conj g1 g2) (conj g1 g3))))
  (((conj g1 g2))
    (let ((g1 (normalize-goal g1))
          (g2 (normalize-goal g2)))
      (if (equal? g1 g2)
          g1
          (conj g1 g2))))
  ((g) g)


    ;  DNF:   (A and B and C) or (D and E and F) or (G and H and I)
    ;         (disj (list (conj (list A B C)) (conj (list D E F))))
    ;         (disj (list A B C)) == (conj A B C)
    ;         (disj (conj A (conj B C)) (disj ,,,))
    ;  CNF:   (A or B or C) and (D or E or F) and (G or H or I)
)

(define (start st g)
  (match (normalize-goal g)
    ((true) (state->stream st))
    ((false) (state->stream #f))
    ((disj g1 g2)
     (step (mplus (pause st g1)
                  (pause st g2))))
    ((conj g1 g2)
     (step (bind (pause st g1) g2)))
    ((relate thunk _)
     (pause st (thunk)))
    ((== t1 t2) (state->stream (unify t1 t2 st)))
    ((=/= t1 t2) (state->stream (disunify t1 t2 st)))
    ((symbolo t) (state->stream (typify t symbol? st)))
    ((stringo t) (state->stream (typify t string? st)))
    ((numbero t) (state->stream (typify t number? st)))
    ((not-symbolo t) (state->stream (not-typify t symbol? st)))
    ((not-stringo t) (state->stream (not-typify t string? st)))
    ((not-numbero t) (state->stream (not-typify t number? st)))
    ((imply g1 g2)
     (step (mplus (pause st (negate-goal g1))
                  (pause st (conj g1 g2)))))
    ; ((forallo v (imply g1 g2))
    ;  (let ((candidates (step (pause st (conj g1 g2)))))
    ;   (if candidates
    ;       (error "There are more candidates in the implies")
    ;       (error "forall failed, no candidates"))))
    ((existo vlst g) (step (pause (extend-scope-multi vlst 'e st) g))) ; TODO change to single variable
    ((forallo vlst g)
     (let* ((v (first vlst))
            (candidates (step (pause st (existo vlst g))))
            (can (and candidates (step candidates))) ; TODO this was a hack, still doesn't work
            (can (and can (car can)))
            (st (extend-scope-multi vlst 'u st)))
        (and can
             (let* ((v-state (get-constraints can v))
                    (v-goal (state->goal v-state)))
                (if (true? v-goal)
                    (state->stream can)
                    (if (state=? (remove-initial can) v-state)
                        (pause st (forallo vlst (conj (negate-goal v-goal) g)))
                        (pause st (forallo vlst (imply (negate-goal v-goal) g)))))))))
    ))

(define (step s)
  (match s
    ((mplus s1 s2)
     (let ((s1 (if (mature? s1) s1 (step s1))))
       (cond ((not s1) s2)
             ((pair? s1)
              (cons (car s1)
                    (mplus s2 (cdr s1))))
             (else (mplus s2 s1)))))
    ((bind s g)
     (let ((s (if (mature? s) s (step s))))
       (cond ((not s) #f)
             ((pair? s)
              (step (mplus (pause (car s) g)
                           (bind (cdr s) g))))
             (else (bind s g)))))
    ((pause st g) (start st g))
    (_            s)))
