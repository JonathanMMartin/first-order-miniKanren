#lang racket
(provide
  (all-from-out "common.rkt")
  (struct-out true)
  (struct-out false)
  (struct-out disj)
  (struct-out conj)
  (struct-out relate)
  (struct-out ==)
  (struct-out =/=)
  (struct-out symbolo)
  (struct-out stringo)
  (struct-out numbero)
  (struct-out not-symbolo)
  (struct-out not-stringo)
  (struct-out not-numbero)
  (struct-out imply)
  (struct-out existo)
  (struct-out forallo)
  (struct-out mplus)
  (struct-out bind)
  (struct-out pause)
  step
  mature
  mature?
  normalize-goal)

(require "common.rkt")

;; first-order microKanren
(struct true        ()                       #:prefab)
(struct false       ()                       #:prefab)
(struct disj        (g1 g2)                  #:prefab)
(struct conj        (g1 g2)                  #:prefab)
(struct relate      (thunk description)      #:prefab)
(struct ==          (t1 t2)                  #:prefab)
(struct =/=         (t1 t2)                  #:prefab)
(struct symbolo     (t)                      #:prefab)
(struct stringo     (t)                      #:prefab)
(struct numbero     (t)                      #:prefab)
(struct not-symbolo (t)                      #:prefab)
(struct not-stringo (t)                      #:prefab)
(struct not-numbero (t)                      #:prefab)
(struct imply       (g1 g2)                  #:prefab)
(struct existo      (v g)                    #:prefab)
(struct forallo     (v g)                    #:prefab)
(struct bind        (bind-s bind-g)          #:prefab)
(struct mplus       (mplus-s1 mplus-s2)      #:prefab)
(struct pause       (pause-state pause-goal) #:prefab)

(define (negate-goal g)
  (cond
    ((true? g)      (false))
    ((false? g)     (true))
    ((disj? g)      (conj (negate-goal (disj-g1 g)) (negate-goal (disj-g2 g))))
    ((conj? g)      (disj (negate-goal (conj-g1 g)) (negate-goal (conj-g2 g))))
    ((==? g)        (=/= (==-t1 g) (==-t2 g)))
    ((=/=? g)       (== (=/=-t1 g) (=/=-t2 g)))
    ((typeo? g)     (type->goal (typeo-t g) (typeo->type? g) #t))
    ((not-typeo? g) (type->goal (typeo-t g) (typeo->type? g)))
    ((imply? g)     (conj (imply-g1 g) (negate-goal (imply-g2 g))))
    ((existo? g)    (forallo (existo-v g) (negate-goal (existo-g g))))
    ((forallo? g)   (existo (forallo-v g) (negate-goal (forallo-g g))))
    (else           (error "Unnegateable goal" g))))

(define (mature? s) (or (not s) (pair? s)))
(define (mature s)
  (if (mature? s) s (mature (step s))))

(define (start st g)
  (match (normalize-decidable g)
    ((true) (state->stream st))
    ((false) (state->stream #f))
    ((disj g1 g2)
     (step (mplus (pause st g1)
                  (pause st g2))))
    ((conj g1 g2)
     (step (bind (pause st g1) g2)))
    ((relate thunk _)
     (pause st (thunk)))
    ((== t1 t2) (state->stream (unify t1 t2 st)))
    ((=/= t1 t2) (state->stream (disunify t1 t2 st)))
    ((symbolo t) (state->stream (typify t symbol? st)))
    ((stringo t) (state->stream (typify t string? st)))
    ((numbero t) (state->stream (typify t number? st)))
    ((not-symbolo t) (state->stream (not-typify t symbol? st)))
    ((not-stringo t) (state->stream (not-typify t string? st)))
    ((not-numbero t) (state->stream (not-typify t number? st)))
    ((imply g1 g2)
     (step (mplus (pause st (negate-goal g1))   ;; This will only work the the goal g1 is decidable, how will we solve non-decidable goals?
                  (pause st (conj g1 g2)))))
    ((existo v g) (step (pause (add-to-scope v 'e st) g)))
    ((forallo v g) (error "not enough rules: forall"))
    ))

(define (step s)
  (match s
    ((mplus s1 s2)
     (let ((s1 (if (mature? s1) s1 (step s1))))
       (cond ((not s1) s2)
             ((pair? s1)
              (cons (car s1)
                    (mplus s2 (cdr s1))))
             (else (mplus s2 s1)))))
    ((bind s g)
     (let ((s (if (mature? s) s (step s))))
       (cond ((not s) #f)
             ((pair? s)
              (step (mplus (pause (car s) g)
                           (bind (cdr s) g))))
             (else (bind s g)))))
    ((pause st g) (start st g))
    (_            s)))

(define (decidable? g)
  (cond
    ((true? g)      #t)
    ((false? g)     #t)
    ((==? g)        #t)
    ((=/=? g)       #t)
    ((disj/conj? g) (and (decidable? (disj/conj-g1 g)) (decidable? (disj/conj-g2 g))))
    ((typeo? g)     #t)
    ((not-typeo? g) #t)
    ((imply? g)     (and (decidable? (imply-g1 g)) (decidable? (imply-g2 g))))
    ((existo? g)    (decidable? (existo-g g)))
    ((forallo? g)   (decidable? (forallo-g g)))
    (else           #f)))

(define (normalize-decidable g)
  (cond
    ((decidable? g) (normalize-goal g))
    ((disj/conj? g) (let ((g1 (normalize-decidable (disj/conj-g1 g))))
                      (match g1
                        ((true)   (if (disj? g) (true) (normalize-decidable (conj-g2 g))))
                        ((false)  (if (disj? g) (normalize-decidable (disj-g2 g)) (false)))
                        (_        (let ((g2 (normalize-decidable (disj/conj-g2 g))))
                                    (match g2
                                      ((true)   (if (disj? g) (true) g2))
                                      ((false)  (if (disj? g) g1 (false)))
                                      (_        (if (disj? g) (disj g1 g2) (conj g1 g2)))))))))
    ((imply? g)     (let ((g1 (normalize-decidable (imply-g1 g))))
                      (cond 
                        ((true? g1)   (normalize-decidable (imply-g2 g)))
                        ((false? g1)  (true))
                        (else         (let ((g2 (normalize-decidable (imply-g2 g))))
                                        (if (decidable? g1)
                                            (disj (normalize-goal (negate-goal g1)) g2)
                                            (imply g1 g2)))))))
    ((existo? g)    (existo (existo-v g) (normalize-decidable (existo-g g))))
    ((forallo? g)   (forallo (forallo-v g) (normalize-decidable (forallo-g g))))
    (else           g)))

(define (normalize-goal g [DNF? #t])
  (cond
    ;; remove lists/pairs
    ((and (==? g) (pair? (==-t1 g)) (pair? (==-t2 g))) (normalize-goal (conj (== (car (==-t1 g)) (car (==-t2 g))) (== (cdr (==-t1 g)) (cdr (==-t2 g)))) DNF?))
    ; ((and (==? g) (pair? (==-t1 g))) (if (var? (==-t2 g)) g (false)))
    ; ((and (==? g) (pair? (==-t2 g))) (if (var? (==-t1 g)) (== (==-t2 g) (==-t1 g)) (false)))
    
    ; ((and (=/=? g) (pair? (=/=-t1 g)) (pair? (=/=-t2 g))) (normalize-goal (disj (=/= (car (=/=-t1 g)) (car (=/=-t2 g))) (=/= (cdr (=/=-t1 g)) (cdr (=/=-t2 g)))) DNF?))
    ; ((and (=/=? g) (pair? (=/=-t1 g))) (if (var? (=/=-t2 g)) g (false)))
    ; ((and (=/=? g) (pair? (=/=-t2 g))) (if (var? (=/=-t1 g)) (=/= (=/=-t2 g) (=/=-t1 g)) (false)))

    ;; Basic things
    ((==? g)  (let ((t1 (==-t1 g)) (t2 (==-t2 g)))
                (cond
                  ((equal? t1 t2) (true))
                  ((and (var? t1) (term-use-var? t2 t1) (not (var? t2))) (false))
                  ((and (var? t2) (term-use-var? t1 t2) (not (var? t1))) (false))
                  ((and (or (contains-fresh? t1) (contains-fresh? t2)) (term<? t1 t2)) (== t1 t2))
                  ((or (contains-fresh? t1) (contains-fresh? t2)) (== t2 t1))
                  (else (false)))))
    ((=/=? g) (let ((t1 (=/=-t1 g)) (t2 (=/=-t2 g)))
                (cond
                  ((equal? t1 t2) (false))
                  ((and (var? t1) (term-use-var? t2 t1) (not (var? t2))) (true))
                  ((and (var? t2) (term-use-var? t1 t2) (not (var? t1))) (true))
                  ((and (or (contains-fresh? t1) (contains-fresh? t2)) (term<? t1 t2)) (=/= t1 t2))
                  ((or (contains-fresh? t1) (contains-fresh? t2)) (=/= t2 t1))
                  (else (true)))))
    
    ((typeo? g)     (let ((t (typeo-t g))) (if (var? t) g (if ((typeo->type? g) t) (true) (false)))))
    ((not-typeo? g) (let ((t (typeo-t g))) (if (var? t) g (if ((typeo->type? g) t) (false) (true)))))
    
    ;; Recursive normalization
    ((disj? g)      (normalize-disj (disj-g1 g) (disj-g2 g) DNF?))
    ((conj? g)      (normalize-conj (conj-g1 g) (conj-g2 g) DNF?))
    ((imply? g)     (normalize-imply (imply-g1 g) (imply-g2 g) DNF?))
    ((existo? g)    (normalize-exists (existo-v g) (existo-g g) DNF?))
    ((forallo? g)   (normalize-forall (forallo-v g) (forallo-g g) DNF?))
    
    (else           g)))

(define (normalize-disj g1 g2 [DNF? #t])
  (let ((g1 (normalize-goal g1 DNF?)))
    (cond
      ((true? g1)  (true))                      ;; True or A = True
      ((false? g1) (normalize-goal g2 DNF?))    ;; False or A = A
      (else (let ((g2 (normalize-goal g2 DNF?)))
              (cond
                ((true? g2)   (true))           ;; A or True = True
                ((false? g2)  g1)               ;; A or False = A
                ((and (not DNF?) (conj? g1))  (error "CNF not implemented"))
                ((and (not DNF?) (conj? g2))  (error "CNF not implemented"))
                ((disj? g1)   (normalize-goal (disj (disj-g1 g1) (disj (disj-g2 g1) g2)) DNF?))
                ((and (disj? g2) (goal-diseq-first<? (disj-g1 g2) g1)) (normalize-goal (disj (disj-g1 g2) (disj g1 (disj-g2 g2))) DNF?))
                ((goal-diseq-first<? g2 g1) (normalize-goal (disj g2 g1) DNF?))
                ((or (=/=? g1) (typeo? g1) (not-typeo? g1))
                  (let ((g2 (if (=/=? g1)
                                (substitute-term g2 (=/=-t2 g1) (=/=-t1 g1) DNF?)
                                (apply-type g2 (typeo-t g1) (typeo->type? g1) DNF? (typeo? g1)))))
                    (match g2
                      ((true)   (true))
                      ((false)  g1)
                      (_        (disj g1 g2)))))
                ((goal=? g1 g2) g1)             ;; A or A = A
                ((negation? g1 g2) (true))      ;; A or ~A = True
                (else (disj g1 g2))))))))

(define (normalize-conj g1 g2 [DNF? #t])
  (let ((g1 (normalize-goal g1 DNF?)))
    (cond
      ((true? g1)   (normalize-goal g2 DNF?))   ;; True and A = A
      ((false? g1)  (false))                    ;; False and A = False
      (else (let ((g2 (normalize-goal g2 DNF?)))
              (cond
                ((true? g2)   g1)               ;; A and True = A
                ((false? g2)  (false))          ;; A and False = False
                ((and DNF? (disj? g1)) (normalize-goal (disj (conj (disj-g1 g1) g2) (conj (disj-g2 g1) g2)) DNF?))  ;; (A or B) and C = (A and C) or (B and C)
                ((and DNF? (disj? g2)) (normalize-goal (disj (conj g1 (disj-g1 g2)) (conj g1 (disj-g2 g2))) DNF?))  ;; A and (B or C) = (A and B) or (A and C)
                ((conj? g1)            (normalize-goal (conj (conj-g1 g1) (conj (conj-g2 g1) g2)) DNF?))            ;; (A and B) and C = A and (B and C)
                ((and (conj? g2) (goal<? (conj-g1 g2) g1)) (normalize-goal (conj (conj-g1 g2) (conj g1 (conj-g2 g2))) DNF?))
                ((goal<? g2 g1) (normalize-goal (conj g2 g1) DNF?))
                ((or (==? g1) (typeo? g1) (not-typeo? g1))
                  (let ((g2 (if (==? g1)
                                (substitute-term g2 (==-t2 g1) (==-t1 g1) DNF?)
                                (apply-type g2 (typeo-t g1) (typeo->type? g1) DNF? (not-typeo? g1)))))
                    (match g2
                      ((true) g1)
                      ((false) (false))
                      (_ (conj g1 g2)))))
                ((goal=? g1 g2) g1)             ;; A and A = A
                ((negation? g1 g2) (false))     ;; A and ~A = False
                (else (conj g1 g2))))))))

(define (normalize-imply g1 g2 [DNF? #t])
  (let ((g1 (normalize-goal g1 DNF?)))
    (cond
      ((true? g1) (normalize-goal g2 DNF?))     ;; True -> A  = A
      ((false? g1) (true))                      ;; False -> A = True
      (else (let ((g1 (normalize-goal (negate-goal g1) DNF?))
                  (g2 (normalize-goal g2 DNF?)))
              (normalize-goal (disj g1 g2) DNF?))))))  ;; A -> B = ~A or B 

(define (normalize-exists v g [DNF? #t])
  (let ((g (normalize-goal g DNF?)))
    (cond
      ((true? g)  (true))
      ((false? g) (false))
      ((==? g)    (let ((t1 (==-t1 g)) (t2 (==-t2 g)))
                    (cond
                      ((or (equal? t1 v) (equal? t2 v)) (true))
                      ((or (term-use-var? t1 v) (term-use-var? t2 v)) (existo v g))
                      (else g))))
      ((=/=? g)   (if (or (term-use-var? (=/=-t1 g) v) (term-use-var? (=/=-t2 g) v)) (true) g))
      ((or (typeo? g) (not-typeo? g)) (if (term-use-var? (typeo-t g) v) (true) g))
      ((imply? g)   (if (or (goal-use-var? (imply-g1 g) v) (goal-use-var? (imply-g2 g) v))
                        (existo v g)
                        g))
      ((existo? g)  (if (goal-use-var? (existo-g g) v) (existo v g) g))
      ((forallo? g) (if (goal-use-var? (forallo-g g) v)
                        (existo v g)
                        (normalize-goal (negate-goal (normalize-goal (negate-goal g) DNF?)) DNF?)))
      ((disj? g)    (let* ((g1 (disj-g1 g)) 
                           (g2 (disj-g2 g))
                           (no-v-in-g1? (not (goal-use-var? g1 v)))
                           (no-v-in-g2? (not (goal-use-var? g2 v))))
                      (cond
                        ((and no-v-in-g1? no-v-in-g2?) g)
                        (no-v-in-g1? (normalize-goal (disj g1 (existo v g2)) DNF?))
                        (no-v-in-g2? (normalize-goal (disj g2 (existo v g1)) DNF?))
                        (else (existo v g)))))
      ((conj? g)    (let* ((g1 (conj-g1 g))
                           (g2 (conj-g2 g))
                           (no-v-in-g1? (not (goal-use-var? g1 v)))
                           (no-v-in-g2? (not (goal-use-var? g2 v))))
                      (cond
                        ((and no-v-in-g1? no-v-in-g2?) g)
                        (no-v-in-g1? (normalize-goal (conj g1 (existo v g2)) DNF?))
                        (no-v-in-g2? (normalize-goal (conj g2 (existo v g1)) DNF?))
                        ((and (=/=? g1) (=/=? g2)) (true))
                        ((and (=/=? g1) (conj? g2) (=/=? (disj-g1 g2))) (true))
                        ((and (not-typeo? g1) (not-typeo? g2) (equal? (typeo-t g1) (typeo-t g2))) (true))
                        ((and (not-typeo? g1) (conj? g2) (not-typeo? (conj-g1 g2)) (equal? (typeo-t g1) (typeo-t (conj-g1 g2))) (true)))
                        (else (existo v g)))))
      (else         (existo v g)))))

(define (normalize-forall v g [DNF? #t])
  (let ((g (normalize-goal g DNF?)))
    (cond
      ((true? g)  (true))
      ((false? g) (false))
      ((==? g)    (if (or (term-use-var? (==-t1 g) v) (term-use-var? (==-t2 g) v)) (false) g))
      ((=/=? g)   (let ((t1 (=/=-t1 g)) (t2 (=/=-t2 g)))
                    (cond
                      ((or (equal? t1 v) (equal? t2 v)) (false))
                      ((or (term-use-var? t1 v) (term-use-var? t2 v)) (error "Currently can't solve 1" g))
                      (else g))))
      
      ((or (typeo? g) (not-typeo? g)) (if (term-use-var? (typeo-t g) v) (false) g))
      
      ((imply? g)   (if (or (goal-use-var? (imply-g1 g) v) (goal-use-var? (imply-g2 g) v))
                        (error "Currently can't solve 2" g)
                        g))
      ((existo? g)  (if (goal-use-var? (existo-g g) v)
                        (error "Currently can't solve 3" g) 
                        g))
      ((forallo? g) (if (goal-use-var? (forallo-g g) v)
                        (error "Currently can't solve 4" g)
                        (normalize-goal (negate-goal (normalize-goal (negate-goal g) DNF?)) DNF?)))
      ((disj? g)    (let* ((g1 (disj-g1 g)) 
                           (g2 (disj-g2 g))
                           (no-v-in-g1? (not (goal-use-var? g1 v)))
                           (no-v-in-g2? (not (goal-use-var? g2 v))))
                      (cond
                        ((and no-v-in-g1? no-v-in-g2?) (disj g1 g2))
                        (no-v-in-g1? (normalize-goal (disj g1 (forallo v g2)) DNF?))
                        (no-v-in-g2? (normalize-goal (disj g2 (forallo v g1)) DNF?))
                        ((and (==? g1) (==? g2)) (false))
                        ((and (==? g1) (disj? g2) (==? (disj-g1 g2))) (false))
                        ((and (typeo? g1) (typeo? g2)) (false))
                        ((and (typeo? g1) (disj? g2) (typeo? (disj-g1 g2))) (false))
                        (else (normalize-goal (negate-goal (normalize-goal (negate-goal (forallo v g)) DNF?)) DNF?)))))   ;; WARNING: this may cause infinite recursion
      ((conj? g)    (let* ((g1 (conj-g1 g))
                           (g2 (conj-g2 g))
                           (no-v-in-g1? (not (goal-use-var? g1 v)))
                           (no-v-in-g2? (not (goal-use-var? g2 v))))
                      (cond
                        ((and no-v-in-g1? no-v-in-g2?) (conj g1 g2))
                        (no-v-in-g1? (normalize-goal (conj g1 (forallo v g2)) DNF?))
                        (no-v-in-g2? (normalize-goal (conj g2 (forallo v g1)) DNF?))
                        (else (normalize-goal (conj (forallo v g1) (forallo v g2)) DNF?)))))
      (else         (forallo v g)))))

(define (disj/conj? g)
  (or (disj? g) (conj? g)))

(define (disj/conj-g1 g)
  (if (disj? g)
      (disj-g1 g)
      (conj-g1 g)))

(define (disj/conj-g2 g)
  (if (disj? g)
      (disj-g2 g)
      (conj-g2 g)))

(define (typeo? g)
  (or (symbolo? g) (stringo? g) (numbero? g)))

(define (not-typeo? g)
  (or (not-symbolo? g) (not-stringo? g) (not-numbero? g)))

(define (typeo-t g)
  (match g
    ((symbolo t)      t)
    ((stringo t)      t)
    ((numbero t)      t)
    ((not-symbolo t)  t)
    ((not-stringo t)  t)
    ((not-numbero t)  t)
    (_ (error "typeo-t: invalid goal" g))))

(define (typeo->type? g)
  (match g
    ((symbolo _)      symbol?)
    ((not-symbolo _)  symbol?)
    ((stringo _)      string?)
    ((not-stringo _)  string?)
    ((numbero _)      number?)
    ((not-numbero _)  number?)
    (_ (error "type->type?: Invalid type" g))))

(define (type->goal t type? [not-type? #f])
  (cond
    ((and not-type? (eq? type? symbol?)) (not-symbolo t))
    ((eq? type? symbol?)                 (symbolo t))
    ((and not-type? (eq? type? string?)) (not-stringo t))
    ((eq? type? string?)                 (stringo t))
    ((and not-type? (eq? type? number?)) (not-numbero t))
    ((eq? type? number?)                 (numbero t))
    (else (error "type->goal: Invalid type"))))

(define (goal-use-var? g v)
  (cond
    ((true? g)        #f)
    ((false? g)       #f)
    ((disj/conj? g)   (or (goal-use-var? (disj/conj-g1 g) v) (goal-use-var? (disj/conj-g2 g) v)))
    ((==? g)          (or (term-use-var? (==-t1 g) v) (term-use-var? (==-t2 g) v)))
    ((=/=? g)         (or (term-use-var? (=/=-t1 g) v) (term-use-var? (=/=-t2 g) v)))
    ((typeo? g)       (term-use-var? (typeo-t g) v))
    ((not-typeo? g)   (term-use-var? (typeo-t g) v))
    ((imply? g)       (or (goal-use-var? (imply-g1 g) v) (goal-use-var? (imply-g2 g) v)))
    ((existo? g)      (goal-use-var? (existo-g g) v))
    ((forallo? g)     (goal-use-var? (forallo-g g) v))
    (else             (error "Can't check goal" g))))

;; substitute v with term everywhere in g
(define (substitute-term g v term [DNF? #t])
  (cond
    ((true? g)                      (true))
    ((false? g)                     (false))
    ((disj? g)                      (normalize-goal (disj (substitute-term (disj-g1 g) v term DNF?) (substitute-term (disj-g2 g) v term DNF?)) DNF?))
    ((conj? g)                      (normalize-goal (conj (substitute-term (conj-g1 g) v term DNF?) (substitute-term (conj-g2 g) v term DNF?)) DNF?))
    ((==? g)                        (normalize-goal (== (if (equal? (==-t1 g) v) term (==-t1 g)) (if (equal? (==-t2 g) v) term (==-t2 g)))))
    ((=/=? g)                       (normalize-goal (=/= (if (equal? (=/=-t1 g) v) term (=/=-t1 g)) (if (equal? (=/=-t2 g) v) term (=/=-t2 g)))))
    ((or (typeo? g) (not-typeo? g)) (normalize-goal (type->goal (if (equal? (typeo-t g) v) term (typeo-t g)) (typeo->type? g) (not-typeo? g))))
    ((imply? g)                     (normalize-goal (imply (substitute-term (imply-g1 g) v term DNF?) (substitute-term (imply-g2 g) v term DNF?)) DNF?))
    ((existo? g)                    (normalize-goal (existo (existo-v g) (substitute-term (existo-g g) v term DNF?)) DNF?))
    ((forallo? g)                   (normalize-goal (forallo (forallo-v g) (substitute-term (forallo-g g) v term DNF?)) DNF?))
    (else                           (error "Couldn't parse goal" g))))

(define (apply-type g v type? [DNF? #t] [not-type? #f])
  (cond
    ((true? g)        (true))
    ((false? g)       (false))
    ((disj? g)        (normalize-goal (disj (apply-type (disj-g1 g) v type? DNF? not-type?) (apply-type (disj-g2 g) v type? DNF? not-type?)) DNF?))
    ((conj? g)        (normalize-goal (conj (apply-type (conj-g1 g) v type? DNF? not-type?) (apply-type (conj-g2 g) v type? DNF? not-type?)) DNF?))
    ((==? g)          (if (and (equal? v (==-t2 g)) (not (var? (==-t1 g))) (eq? not-type? (type? (==-t1 g))))
                          (false)
                          g))
    ((=/=? g)         (if (and (equal? v (=/=-t2 g)) (not (var? (=/=-t1 g))) (eq? not-type? (type? (=/=-t1 g))))
                          (true)
                          g))
    ((typeo? g)       (cond
                        ((and (equal? v (typeo-t g)) (equal? (typeo->type? g) type?)) (if not-type? (false) (true)))
                        ((and (equal? v (typeo-t g))) (if not-type? g (false)))
                        (else g)))
    ((not-typeo? g)   (cond
                        ((and (equal? v (typeo-t g)) (equal? (typeo->type? g) type?)) (if not-type? (true) (false)))
                        ((equal? v (typeo-t g)) (if not-type? g (true)))
                        (else g)))
    ((imply? g)       (normalize-goal (imply (apply-type (imply-g1 g) v type? DNF? not-type?) (apply-type (imply-g2 g) v type? DNF? not-type?))))
    ((existo? g)      (normalize-goal (existo (existo-v g) (apply-type (existo-g g) v type? DNF? not-type?))))
    ((forallo? g)     (normalize-goal (forallo (forallo-v g) (apply-type (forallo-g g) v type? DNF? not-type?))))
    (else             (error "Couldn't parse goal" g))))

(define (goal=? g1 g2)    ;; Assumes that g1 and g2 are normalized
  (cond
    ((existo? g1)   (and (existo? g2) (goal=? (existo-g g1) (substitute-term (existo-g g2) (existo-v g2) (existo-v g1)))))
    ((forallo? g1)  (and (forallo? g2) (goal=? (forallo-g g1) (substitute-term (forallo-g g2) (forallo-v g2) (forallo-v g1)))))
    (else           (equal? g1 g2))))

(define (negation? g1 g2) ;; Assumes that g1 and g2 are normalized, assumes that g1 and g2 are not equal
  (cond
    ((true? g1)      (false? g2))
    ((false? g1)     (true? g2))
    ((==? g1)        (and (=/=? g2) (equal? (==-t1 g1) (=/=-t1 g2)) (equal? (==-t2 g1) (=/=-t2 g2))))
    ((=/=? g1)       (and (==? g2) (equal? (=/=-t1 g1) (==-t1 g2)) (equal? (=/=-t2 g1) (==-t2 g2))))
    ((typeo? g1)     (and (not-typeo? g2) (equal? (typeo->type? g1) (typeo->type? g2)) (equal? (typeo-t g1) (typeo-t g2))))
    ((not-typeo? g1) (and (typeo? g2) (equal? (typeo->type? g1) (typeo->type? g2)) (equal? (typeo-t g1) (typeo-t g2))))
    ((existo? g1)    (and (forallo? g2) (negation? (existo-g g1) (substitute-term (forallo-g g2) (forallo-v g2) (existo-v g1)))))
    ((forallo? g1)   (and (existo? g2) (negation? (forallo-g g1) (substitute-term (existo-g g2) (existo-v g2) (existo-v g1)))))
    ((existo? g2)    #f)
    ((forallo? g2)   #f)
    ((imply? g1)     (negation? (disj (negate-goal (imply-g1 g1)) (imply-g2 g1))) g2)
    (else            (goal=? g1 (negate-goal g2)))))
      
(define (goal<? g1 g2)
  (eqv? (goal-compare g1 g2) -1))

(define (goal-diseq-first<? g1 g2)
  (eqv? (goal-diseq-first-compare g1 g2) -1))

(define (goal-compare g1 g2)
  (cond
    ((true? g1)         -1)
    ((true? g2)         1)
    ((false? g1)        -1)
    ((false? g2)        1)
    ((==? g1)           (cond
                          ((and (==? g2) (equal? (==-t1 g1) (==-t1 g2))) (term-compare (==-t2 g1) (==-t2 g2)))
                          ((==? g2) (term-compare (==-t1 g1) (==-t1 g2)))
                          (else -1)))
    ((==? g2)           1)
    ((symbolo? g1)      (if (symbolo? g2) (term-compare (symbolo-t g1) (symbolo-t g2)) -1))
    ((symbolo? g2)      1)
    ((stringo? g1)      (if (stringo? g2) (term-compare (stringo-t g1) (stringo-t g2)) -1))
    ((stringo? g2)      1)
    ((numbero? g1)      (if (numbero? g2) (term-compare (numbero-t g1) (numbero-t g2)) -1))
    ((numbero? g2)      1)
    ((not-symbolo? g1)  (if (not-symbolo? g2) (term-compare (not-symbolo-t g1) (not-symbolo-t g2)) -1))
    ((not-symbolo? g2)  1)
    ((not-stringo? g1)  (if (not-stringo? g2) (term-compare (not-stringo-t g1) (not-stringo-t g2)) -1))
    ((not-stringo? g2)  1)
    ((not-numbero? g1)  (if (not-numbero? g2) (term-compare (not-numbero-t g1) (not-numbero-t g2)) -1))
    ((not-numbero? g2)  1)
    ((=/=? g1)          (cond
                          ((and (=/=? g2) (equal? (=/=-t1 g1) (=/=-t1 g2))) (term-compare (=/=-t2 g1) (=/=-t2 g2)))
                          ((=/=? g2) (term-compare (=/=-t1 g1) (=/=-t1 g2)))
                          (else -1)))
    ((=/=? g2)          1)
    ((imply? g1)        (if (imply? g2)
                            (let ((compared-g1 (goal-compare (imply-g1 g1) (imply-g1 g2))))
                              (if (eqv? 0 compared-g1) (goal-compare (imply-g2 g1) (imply-g2 g2)) compared-g1))
                            -1))
    ((imply? g2)        1)
    ((existo? g1)       (if (existo? g2) (if (< (var-index (existo-v g1)) (var-index (existo-v g2))) -1 1) -1))
    ((existo? g2)       1)
    ((forallo? g1)      (if (forallo? g2) (if (< (var-index (forallo-v g1)) (var-index (forallo-v g2))) -1 1) -1))
    ((forallo? g2)      1)
    ((conj? g1)         (if (conj? g2)
                            (let ((compared-g1 (goal-compare (conj-g1 g1) (conj-g1 g2))))
                              (if (eqv? compared-g1 0) 
                                  (goal-compare (conj-g2 g1) (conj-g2 g2)) 
                                  compared-g1))
                            -1))
    ((conj? g2)         1)
    ((disj? g1)         (if (disj? g2)
                            (let ((compared-g1 (goal-compare (disj-g1 g1) (disj-g1 g2))))
                              (if (eqv? compared-g1 0) 
                                  (goal-compare (disj-g2 g1) (disj-g2 g2)) 
                                  compared-g1))
                            -1))
    ((disj? g2)         1)
    (else               0)))

(define (goal-diseq-first-compare g1 g2)
  (cond
    ((true? g1)         -1)
    ((true? g2)         1)
    ((false? g1)        -1)
    ((false? g2)        1)
    ((=/=? g1)          (cond
                          ((and (=/=? g2) (equal? (=/=-t1 g1) (=/=-t1 g2))) (term-compare (=/=-t2 g1) (=/=-t2 g2)))
                          ((=/=? g2) (term-compare (=/=-t1 g1) (=/=-t1 g2)))
                          (else -1)))
    ((=/=? g2)          1)
    ((not-numbero? g1)  (if (not-numbero? g2) (term-compare (not-numbero-t g1) (not-numbero-t g2)) -1))
    ((not-numbero? g2)  1)
    ((not-stringo? g1)  (if (not-stringo? g2) (term-compare (not-stringo-t g1) (not-stringo-t g2)) -1))
    ((not-stringo? g2)  1)
    ((not-symbolo? g1)  (if (not-symbolo? g2) (term-compare (not-symbolo-t g1) (not-symbolo-t g2)) -1))
    ((not-symbolo? g2)  1)
    ((numbero? g1)      (if (numbero? g2) (term-compare (numbero-t g1) (numbero-t g2)) -1))
    ((numbero? g2)      1)
    ((stringo? g1)      (if (stringo? g2) (term-compare (stringo-t g1) (stringo-t g2)) -1))
    ((stringo? g2)      1)
    ((symbolo? g1)      (if (symbolo? g2) (term-compare (symbolo-t g1) (symbolo-t g2)) -1))
    ((symbolo? g2)      1)
    ((==? g1)           (cond
                          ((and (==? g2) (equal? (==-t1 g1) (==-t1 g2))) (term-compare (==-t2 g1) (==-t2 g2)))
                          ((==? g2) (term-compare (==-t1 g1) (==-t1 g2)))
                          (else -1)))
    ((==? g2)           1)
    (else               (goal-compare g1 g2))))