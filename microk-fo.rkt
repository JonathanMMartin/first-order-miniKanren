#lang racket
(provide
  (all-from-out "common.rkt")
  (struct-out disj)
  (struct-out conj)
  (struct-out relate)
  (struct-out ==)
  (struct-out =/=)
  (struct-out symbolo)
  (struct-out stringo)
  (struct-out numbero)
  (struct-out not-symbolo)
  (struct-out not-stringo)
  (struct-out not-numbero)
  (struct-out imply)
  (struct-out existo)
  (struct-out forallo)
  (struct-out mplus)
  (struct-out bind)
  (struct-out pause)
  step
  mature
  mature?
  normalize-goal)

(require "common.rkt")

;; first-order microKanren
(struct true     ()                      #:prefab)
(struct false    ()                      #:prefab)
(struct disj    (g1 g2)                  #:prefab)
(struct conj    (g1 g2)                  #:prefab)
(struct relate  (thunk description)      #:prefab)
(struct ==      (t1 t2)                  #:prefab)
(struct =/=     (t1 t2)                  #:prefab)
(struct symbolo (t)                      #:prefab)
(struct stringo (t)                      #:prefab)
(struct numbero (t)                      #:prefab)
(struct not-symbolo (t)                  #:prefab)
(struct not-stringo (t)                  #:prefab)
(struct not-numbero (t)                  #:prefab)
(struct imply   (g1 g2)                  #:prefab)
(struct existo  (v g)                    #:prefab)
(struct forallo (v g)                    #:prefab)
(struct bind    (bind-s bind-g)          #:prefab)
(struct mplus   (mplus-s1 mplus-s2)      #:prefab)
(struct pause   (pause-state pause-goal) #:prefab)

(define (mature? s) (or (not s) (pair? s)))
(define (mature s)
  (if (mature? s) s (mature (step s))))

;; Implication
(define (negate-goal g)
  (match g
    ((true)           (false))
    ((false)          (true))
    ((conj g1 g2)     (disj (negate-goal g1) (negate-goal g2)))
    ((disj g1 g2)     (conj (negate-goal g1) (negate-goal g2)))
    ((== t1 t2)       (=/= t1 t2))
    ((=/= t1 t2)      (== t1 t2))
    ((symbolo t)      (not-symbolo t))
    ((stringo t)      (not-stringo t))
    ((numbero t)      (not-numbero t))
    ((not-symbolo t)  (symbolo t))
    ((not-stringo t)  (stringo t))
    ((not-numbero t)  (numbero t))
    ((imply g1 g2)    (conj g1 (negate-goal g2)))
    ((existo v g)     (forallo v (negate-goal g)))
    ((forallo v g)    (existo v (negate-goal g)))
    (_                (error "unnegateable goal" g))
    ))

(define (state->goal st)
  (let* ((sub (state-sub st))
         (diseq (state-diseq st))
         (types (state-types st))
         (not-types (state-not-types st)))
    (sub->goal sub (true))))

(define (sub->goal sub acc)
  (match sub
    ('() acc)
    ((cons (cons x y) rest) (sub->goal rest (conj (== x y) acc)))))

(define (types->goal types acc)
  (match types
    ('() acc)
    ((cons (cons v type?) rest) (types->goal rest (conj type->goal-helper v type?) acc))))

(define (type->goal-helper u type?)
  (cond
    ((eq? type? symbol?) (symbolo u))
    ((eq? type? string?) (stringo u))
    ((eq? type? number?) (numbero u))
    (error "Invalid type")))

(define (goal-use-var? g v)
  (match g
    ((true)           #f)
    ((false)          #f)
    ((conj g1 g2)     (or (goal-use-var? g1 v) (goal-use-var? g2 v)))
    ((disj g1 g2)     (or (goal-use-var? g1 v) (goal-use-var? g2 v)))
    ((== t1 t2)       (or (term-use-var? t1 v) (term-use-var? t2 v)))
    ((=/= t1 t2)      (or (term-use-var? t1 v) (term-use-var? t2 v)))
    ((symbolo t)      (term-use-var? t v))
    ((stringo t)      (term-use-var? t v))
    ((numbero t)      (term-use-var? t v))
    ((not-symbolo t)  (term-use-var? t v))
    ((not-stringo t)  (term-use-var? t v))
    ((not-numbero t)  (term-use-var? t v))
    ((imply g1 g2)    (or (goal-use-var? g1 v) (goal-use-var? g2 v)))
    ((existo x g)     (goal-use-var? g v))
    ((forallo x g)    (goal-use-var? g v))
    (_                (error "can't check goal" g))
    ))

(define (normalize-goal-forall v g)
  (match (normalize-goal g)
    ((false)          (false))
    ((true)           (true))
    ((== t1 t2)       (if (or (term-use-var? t1 v) (term-use-var? t2 v))
                          (false)
                          (== t1 t2)))
    ((=/= t1 t2)      (if (or (term-use-var? t1 v) (term-use-var? t2 v))
                          (false)
                          (=/= t1 t2)))
    ((symbolo t)      (if (term-use-var? t v)
                          (false)
                          (symbolo t)))
    ((stringo t)      (if (term-use-var? t v)
                          (false)
                          (stringo t)))
    ((numbero t)      (if (term-use-var? t v)
                          (false)
                          (numbero t)))
    ((not-symbolo t)  (if (term-use-var? t v)
                          (false)
                          (not-symbolo t)))
    ((not-stringo t)  (if (term-use-var? t v)
                          (false)
                          (not-stringo t)))
    ((not-numbero t)  (if (term-use-var? t v)
                          (false)
                          (not-numbero t)))
    ((imply g1 g2)    (if (or (goal-use-var? g1 v) (goal-use-var? g2 v))
                          (error "Currently can't solve 1")
                          (imply g1 g2)))
    ((existo q h)     (if (goal-use-var? h v)
                          (error "Currently can't solve 2")
                          (existo q h)))
    ((forallo q h)    (if (goal-use-var? h v)
                          (error "Currently can't solve 3")
                          (forallo q h)))
    ((disj g1 g2) (let* ((no-v-in-g1? (not (goal-use-var? g1 v)))
                         (no-v-in-g2? (not (goal-use-var? g2 v))))
                    (cond
                      ((and no-v-in-g1? no-v-in-g2?) (disj g1 g2))
                      (no-v-in-g1? (normalize-goal (disj g1 (forallo v g2))))
                      (no-v-in-g2? (normalize-goal (disj g2 (forallo v g1))))
                      (else (forallo v (disj g1 g2))))))
    ((conj g1 g2) (let* ((no-v-in-g1? (not (goal-use-var? g1 v)))
                         (no-v-in-g2? (not (goal-use-var? g2 v))))
                    (cond
                      ((and no-v-in-g1? no-v-in-g2?) (conj g1 g2))
                      (no-v-in-g1? (normalize-goal (conj g1 (forallo v g2))))
                      (no-v-in-g2? (normalize-goal (conj g2 (forallo v g1))))
                      (else (forallo v (conj g1 g2))))))
    ))

(define (normalize-goal-exists v g)
  (match (normalize-goal g)
    ((false)          (false))
    ((true)           (true))
    ((== t1 t2)       (if (or (term-use-var? t1 v) (term-use-var? t2 v))
                          (existo v (== t1 t2))
                          (== t1 t2)))
    ((=/= t1 t2)      (if (or (term-use-var? t1 v) (term-use-var? t2 v))
                          (existo v (=/= t1 t2))
                          (=/= t1 t2)))
    ((symbolo t)      (if (term-use-var? t v)
                          (existo v (symbolo t))
                          (symbolo t)))
    ((stringo t)      (if (term-use-var? t v)
                          (existo v (stringo t))
                          (stringo t)))
    ((numbero t)      (if (term-use-var? t v)
                          (existo v (numbero t))
                          (numbero t)))
    ((not-symbolo t)  (if (term-use-var? t v)
                          (existo v (not-symbolo t))
                          (not-symbolo t)))
    ((not-stringo t)  (if (term-use-var? t v)
                          (existo v (not-stringo t))
                          (not-stringo t)))
    ((not-numbero t)  (if (term-use-var? t v)
                          (existo v (not-numbero t))
                          (not-numbero t)))
    ((imply g1 g2)    (if (or (goal-use-var? g1 v) (goal-use-var? g2 v))
                          (existo v (imply g1 g2))
                          (imply g1 g2)))
    ((existo q h)     (if (goal-use-var? h v)
                          (existo v (existo q h))
                          (existo q h)))
    ((forallo q h)    (if (goal-use-var? h v)
                          (existo v (forallo q h))
                          (forallo q h)))
    ((disj g1 g2) (let* ((no-v-in-g1? (not (goal-use-var? g1 v)))
                         (no-v-in-g2? (not (goal-use-var? g2 v))))
                    (cond
                      ((and no-v-in-g1? no-v-in-g2?) (disj g1 g2))
                      (no-v-in-g1? (normalize-goal (disj g1 (existo v g2))))
                      (no-v-in-g2? (normalize-goal (disj g2 (existo v g1))))
                      (else (existo v (disj g1 g2))))))
    ((conj g1 g2) (let* ((no-v-in-g1? (not (goal-use-var? g1 v)))
                         (no-v-in-g2? (not (goal-use-var? g2 v))))
                    (cond
                      ((and no-v-in-g1? no-v-in-g2?) (conj g1 g2))
                      (no-v-in-g1? (normalize-goal (conj g1 (existo v g2))))
                      (no-v-in-g2? (normalize-goal (conj g2 (existo v g1))))
                      (else (existo v (conj g1 g2))))))
    ))

(define (vacuous-disj-conj? g negated-first-goal)
  (match g
    ((disj g1 g2) (or (equal? g1 negated-first-goal) (vacuous-disj-conj? g2 negated-first-goal)))
    ((conj g1 g2) (or (equal? g1 negated-first-goal) (vacuous-disj-conj? g2 negated-first-goal)))
    (h (equal? h negated-first-goal))))

;; g1 guarantees a single goal g2 holds
;; g1 must be normalized conj
(define (conj-subsumes-single g1 g2)
  (match g1
    ((conj h1 h2) (or (equal? h1 g2) (conj-subsumes-single h2 g2)))
    (h (equal? h g2))))

;; g1 guarantees all goals in g2 hold
;; g1 and g2 must be normalized conjs
(define (conj-subsumes g1 g2)
  (match g2
    ((conj h1 h2) (and (conj-subsumes-single g1 h1) (conj-subsumes g1 h2)))
    (h (conj-subsumes-single g1 h))))

;; substitute v with term everywhere in g
(define (substitute-term g v term)
  (match g
    ((true)  (true))
    ((false) (false))
    ((conj g1 g2) (conj (substitute-term g1 v term) (substitute-term g2 v term)))
    ((disj g1 g2) (disj (substitute-term g1 v term) (substitute-term g2 v term)))
    ((== t1 t2) (cond
                  ((equal? t1 v) (== term t2))
                  ((equal? t2 v) (== t1 term))
                  (else (== t1 t2))))
    ((=/= t1 t2) (cond
                  ((equal? t1 v) (=/= term t2))
                  ((equal? t2 v) (=/= t1 term))
                  (else (=/= t1 t2))))
    ((symbolo t) (symbolo (if (equal? t v) term t)))
    ((stringo t) (stringo (if (equal? t v) term t)))
    ((numbero t) (numbero (if (equal? t v) term t)))
    ((not-symbolo t) (not-symbolo (if (equal? t v) term t)))
    ((not-stringo t) (not-stringo (if (equal? t v) term t)))
    ((not-numbero t) (not-numbero (if (equal? t v) term t)))
    ((imply g1 g2) (imply (substitute-term g1 v term) (substitute-term g2 v term)))
    ((existo x g) (existo x (substitute-term g v term)))
    ((forallo x g) (forallo x (substitute-term g v term)))
    (_ (error "couldn't parse goal" g))
    ))

(define/match (normalize-goal g)

  ;; remove lists/pairs
  (((== (cons f1 r1) (cons f2 r2))) (normalize-goal (conj (== f1 f2) (== r1 r2))))
  ; (((== (cons f1 r1) t2)) (if (var? t2) (== (cons f1 r1) t2) (false)))
  ; (((== t1 (cons f2 r2))) (if (var? t1) (== (cons f2 r2) t1) (false)))
  
  ; (((=/= (cons f1 r1) (cons f2 r2))) (normalize-goal (disj (=/= f1 f2) (=/= r1 r2))))
  ; (((=/= (cons f1 r1) t2)) (if (var? t2) (=/= (cons f1 r1) t2) (false)))
  ; (((=/= t1 (cons f2 r2))) (if (var? t1) (=/= (cons f2 r2) t1) (false)))

  ;; basic things
  (((== t1 t2))           (cond
                            ((equal? t1 t2) (true))
                            ((and (var? t1) (var? t2)) (if (< (var-index t1) (var-index t2)) (== t1 t2) (== t2 t1)))
                            ((var? t2) (== t1 t2))
                            ((var? t1) (== t2 t1))
                            ((contains-fresh? t2) (== t1 t2))
                            ((contains-fresh? t1) (== t2 t1))
                            (else (false))))
  (((=/= t1 t2))          (cond
                            ((equal? t1 t2) (false))
                            ((and (var? t1) (var? t2)) (if (< (var-index t1) (var-index t2)) (=/= t1 t2) (=/= t2 t1)))
                            ((var? t2) (=/= t1 t2))
                            ((var? t1) (=/= t2 t1))
                            ((contains-fresh? t2) (=/= t1 t2))
                            ((contains-fresh? t1) (=/= t2 t1))
                            (else (true))))
  (((symbolo t))          (if (var? t) g (if (symbol? t) (true) (false))))
  (((stringo t))          (if (var? t) g (if (string? t) (true) (false))))
  (((numbero t))          (if (var? t) g (if (number? t) (true) (false))))
  (((not-symbolo t))      (if (var? t) g (if (symbol? t) (false) (true))))
  (((not-stringo t))      (if (var? t) g (if (string? t) (false) (true))))
  (((not-numbero t))      (if (var? t) g (if (number? t) (false) (true))))
  (((disj (true) _))      (true))
  (((disj _ (true)))      (true))
  (((disj (false) g))     (normalize-goal g))
  (((disj g (false)))     (normalize-goal g))
  (((conj (true) g))      (normalize-goal g))
  (((conj g (true)))      (normalize-goal g))
  (((conj (false) _))     (false))
  (((conj _ (false)))     (false))
  (((imply (true) g))     (normalize-goal g))
  (((imply (false) _))    (true))
  (((existo _ (true)))    (true))
  (((existo _ (false)))   (false))
  (((forallo _ (true)))   (true))
  (((forallo _ (false)))  (false))
  
  ;; DNF for disj
  (((disj (disj g1 g2) g3))
    (normalize-goal (disj g1 (disj g2 g3))))          ;; (A or B) or C = A or (B or C)
  
  ;; Main disj rules
  (((disj g1 g2))
    (let ((h1 (normalize-goal g1))
          (h2 (normalize-goal g2)))
      (cond ((equal? h1 h2) h1)     ;; A or A = A
            ((and (equal? g1 h1) (equal? g2 h2)) 
              (cond
                ((vacuous-disj-conj? h2 (negate-goal h1)) (true))     ;; A or ~A = True
                ((and (not (=/=? h1)) 
                      (or (=/=? h2) (and (disj? h2) (=/=? (disj-g1 h2))))) 
                  (normalize-goal (disj h2 h1)))                      ;; A or (x =/= y) = (x =/= y) or A
                ((and (conj? h1) (conj? h2) (conj-subsumes h1 h2)) (normalize-goal h2))   ;; (A and B and C) or (A and B) = A and B
                ((and (conj? h1) (conj? h2) (conj-subsumes h2 h1)) (normalize-goal h1))   ;; (A and B) or (A and B and C) = A and B
                ((and (=/=? h1) (var? (=/=-t2 h1)) (goal-use-var? h2 (=/=-t2 h1)))
                  (normalize-goal (negate-goal (normalize-goal (negate-goal (disj h1 h2))))))
                (else (disj h1 h2))))
            (else (normalize-goal (disj h1 h2))))))

  ;; DNF for conj
  (((conj (conj g1 g2) g3))
    (normalize-goal (conj g1 (conj g2 g3))))            ;; (A and B) and C = A and (B and C) 
  (((conj (disj g1 g2) g3))
    (normalize-goal (disj (conj g1 g3) (conj g2 g3))))  ;; (A or B) and C  = (A and C) or (B and C)
  (((conj g1 (disj g2 g3)))
    (normalize-goal (disj (conj g1 g2) (conj g1 g3))))  ;; A and (B or C)  = (A and B) or (A and C)
  
  ;; Main conj rules
  (((conj g1 g2))
    (let ((h1 (normalize-goal g1))
          (h2 (normalize-goal g2)))
      (cond ((equal? h1 h2) h1)     ;; A and A = A
            ((and (equal? g1 h1) (equal? g2 h2)) 
              (cond
                ((vacuous-disj-conj? h2 (negate-goal h1)) (false))  ;; A and ~A = False
                ((and (not (==? h1)) 
                      (or (==? h2) (and (conj? h2) (==? (conj-g1 h2))))) 
                  (normalize-goal (conj h2 h1)))                    ;; A and (x == y) = (x == y) and A
                ((==? h1) (let ((h3 (substitute-term h2 (==-t2 h1) (==-t1 h1))))
                            (if (equal? h3 h2) (conj h1 h2) (normalize-goal (conj h1 h3)))))
                (else (conj h1 h2))))
            (else (normalize-goal (conj h1 h2))))))
  
  ;; (imply A B) => (disj ~A B)
  (((imply g1 g2)) (normalize-goal (disj (negate-goal (normalize-goal g1)) g2)))

  ;; exists rules
  (((existo v g)) 
    (normalize-goal-exists v g))

  ;; forall rules
  (((forallo v g))
    (normalize-goal-forall v g))

  ;; no simplifications
  ((g) g))

(define (start st g)
  (match (normalize-goal g)
    ((true) (state->stream st))
    ((false) (state->stream #f))
    ((disj g1 g2)
     (step (mplus (pause st g1)
                  (pause st g2))))
    ((conj g1 g2)
     (step (bind (pause st g1) g2)))
    ((relate thunk _)
     (pause st (thunk)))
    ((== t1 t2) (state->stream (unify t1 t2 st)))
    ((=/= t1 t2) (state->stream (disunify t1 t2 st)))
    ((symbolo t) (state->stream (typify t symbol? st)))
    ((stringo t) (state->stream (typify t string? st)))
    ((numbero t) (state->stream (typify t number? st)))
    ((not-symbolo t) (state->stream (not-typify t symbol? st)))
    ((not-stringo t) (state->stream (not-typify t string? st)))
    ((not-numbero t) (state->stream (not-typify t number? st)))
    ((imply g1 g2)
     (step (mplus (pause st (negate-goal g1))
                  (pause st (conj g1 g2)))))
    ((existo v g) (step (pause (add-to-scope v 'e st) g)))
    ((forallo v g) (error "not enough rules: forall"))
    ))

(define (step s)
  (match s
    ((mplus s1 s2)
     (let ((s1 (if (mature? s1) s1 (step s1))))
       (cond ((not s1) s2)
             ((pair? s1)
              (cons (car s1)
                    (mplus s2 (cdr s1))))
             (else (mplus s2 s1)))))
    ((bind s g)
     (let ((s (if (mature? s) s (step s))))
       (cond ((not s) #f)
             ((pair? s)
              (step (mplus (pause (car s) g)
                           (bind (cdr s) g))))
             (else (bind s g)))))
    ((pause st g) (start st g))
    (_            s)))
